Tuyệt vời! Viết lại Router sử dụng export class là một cách tiếp cận hiện đại và chuyên nghiệp hơn, giúp đóng gói logic định tuyến và quản lý trạng thái tốt hơn.

Chúng ta sẽ tạo một lớp Router và di chuyển logic handleRouting vào một phương thức của lớp đó.

Cấu trúc dự án vẫn giữ nguyên:

your-spa-project/
├── index.html
├── style.css
└── js/
    ├── main.js
    ├── views/
    │   ├── home.js
    │   ├── about.js
    │   ├── contact.js
    │   └── notFound.js
    └── router.js  <-- Sẽ là một class
1. index.html (Không đổi)
Vẫn giữ nguyên như cũ, vì điểm vào chính vẫn là js/main.js dưới dạng module.

HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanilla JS SPA Module Class Router</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav>
        <a href="#home">Trang chủ</a> |
        <a href="#about">Giới thiệu</a> |
        <a href="#contact">Liên hệ</a>
    </nav>

    <div id="app">
        Đang tải nội dung...
    </div>

    <script type="module" src="./js/main.js"></script>
</body>
</html>
2. Các tệp js/views/*.js (Không đổi)
Các tệp này vẫn là các module đơn giản xuất ra hàm lấy nội dung.

js/views/home.js
js/views/about.js
js/views/contact.js
js/views/notFound.js
Chúng vẫn giống hệt như các đoạn code bạn đã cung cấp ở trên.

3. js/router.js (Sử dụng export class)
Đây là phần thay đổi chính. Chúng ta sẽ định nghĩa một lớp Router có thể quản lý việc hiển thị nội dung.

JavaScript

// js/router.js

// Import các hàm lấy nội dung trang từ các module views
import { getHomePageContent } from './views/home.js';
import { getAboutPageContent } from './views/about.js';
import { getContactPageContent } from './views/contact.js';
import { getNotFoundPageContent } from './views/notFound.js';

// Hàm helper để in ra console (nếu cần cho debugging)
function tt(t) {
    console.log(t);
}

// Định nghĩa lớp Router
export class Router {
    constructor(appElement) {
        // Lưu trữ tham chiếu đến phần tử 'app' để sử dụng sau này
        if (!appElement) {
            console.error("Router requires an app element to be provided.");
            return;
        }
        this.appElement = appElement;

        // Gán this cho handleRouteBound để đảm bảo 'this' luôn trỏ đúng trong event listener
        this.handleRouteBound = this.handleRoute.bind(this);
    }

    // Phương thức để bắt đầu lắng nghe sự kiện
    init() {
        // Lắng nghe sự kiện thay đổi hash và gọi phương thức handleRoute
        window.addEventListener('hashchange', this.handleRouteBound);

        // Gọi handleRoute một lần khi tải trang ban đầu
        this.handleRouteBound();
    }

    // Phương thức xử lý định tuyến chính
    handleRoute() {
        const hash = window.location.hash.substring(1);
        tt(hash); // Debugging

        let content = '';

        switch (hash) {
            case 'home':
            case '': // Nếu không có hash hoặc hash rỗng, mặc định là trang chủ
                content = getHomePageContent();
                break;
            case 'about':
                content = getAboutPageContent();
                break;
            case 'contact':
                content = getContactPageContent();
                break;
            default: // Nếu hash không khớp với bất kỳ trang nào
                content = getNotFoundPageContent();
                break;
        }

        // Cập nhật nội dung của phần tử 'app'
        this.appElement.innerHTML = content;
    }

    // Phương thức tùy chọn để điều hướng bằng lập trình
    navigateTo(path) {
        window.location.hash = path;
    }
}
4. js/main.js (Tệp module chính - Sử dụng class Router)
Ở đây, chúng ta sẽ tạo một thể hiện (instance) của lớp Router và gọi phương thức init() của nó.

JavaScript

// js/main.js

import { Router } from './router.js'; // Import lớp Router

// Lấy tham chiếu đến phần tử chứa nội dung SPA
const app = document.getElementById('app');

// Tạo một thể hiện mới của Router, truyền phần tử app vào
const router = new Router(app);

// Khởi tạo router để nó bắt đầu lắng nghe sự kiện và hiển thị trang ban đầu
router.init();

// Bạn có thể thêm các chức năng khác vào đây, ví dụ:
// document.getElementById('someButton').addEventListener('click', () => {
//     router.navigateTo('contact'); // Ví dụ về cách điều hướng bằng lập trình
// });
Giải thích các thay đổi:
Lớp Router:

Được định nghĩa bằng export class Router { ... }.
constructor(appElement): Đây là hàm khởi tạo của lớp. Nó nhận phần tử DOM chính của ứng dụng (div#app) làm đối số và lưu nó vào this.appElement. Điều này giúp lớp Router biết nó cần cập nhật phần tử nào.
this.handleRouteBound = this.handleRoute.bind(this);: Dòng này quan trọng khi làm việc với event listener trong class. Khi một phương thức của class (như handleRoute) được dùng làm callback cho một sự kiện (như hashchange), this bên trong phương thức đó sẽ không còn trỏ đến instance của class nữa mà trỏ đến phần tử DOM đã kích hoạt sự kiện. Bằng cách sử dụng .bind(this), chúng ta tạo ra một phiên bản mới của phương thức handleRoute mà trong đó this luôn được liên kết với instance Router hiện tại.
init() method: Phương thức này được tạo ra để chứa logic khởi tạo router, bao gồm việc thêm event listener và gọi handleRoute lần đầu. Điều này giúp tách biệt việc tạo instance và việc khởi động nó.
handleRoute() method: Logic định tuyến đã được di chuyển vào phương thức này. Nó sử dụng this.appElement để cập nhật nội dung.
MapsTo(path) (tùy chọn): Một phương thức tiện ích để bạn có thể điều hướng đến một đường dẫn cụ thể bằng lập trình, thay vì chỉ dựa vào người dùng nhấp vào liên kết.
js/main.js:

Chỉ đơn giản là import lớp Router.
Tạo một đối tượng router mới bằng new Router(app).
Gọi router.init() để khởi động toàn bộ quá trình định tuyến.
Cách tiếp cận sử dụng class giúp code của bạn có cấu trúc hơn, dễ kiểm thử (testable) hơn và dễ dàng mở rộng các tính năng định tuyến phức tạp hơn sau này.

## hoc

Có, hoàn toàn có thể! Bạn có thể dùng class trong js/views/home.js (và các view khác) để đóng gói logic và cấu trúc nội dung của view. Đây là một cách tiếp cận tốt nếu view của bạn có logic phức tạp hơn, cần quản lý trạng thái nội bộ hoặc tương tác với các sự kiện DOM.

Tuy nhiên, đối với các view đơn giản chỉ trả về một chuỗi HTML tĩnh như hiện tại, việc dùng class có thể hơi "overkill" (quá mức cần thiết). Nhưng nếu bạn có kế hoạch mở rộng các view này trong tương lai (ví dụ: thêm sự kiện, quản lý dữ liệu động), thì việc sử dụng class ngay từ đầu là một ý tưởng hay.

Dưới đây là cách bạn có thể viết lại js/views/home.js sử dụng class:

js/views/home.js (Sử dụng export class)
JavaScript

// js/views/home.js

export class HomePage {
    constructor() {
        // Constructor có thể được sử dụng để khởi tạo trạng thái
        // hoặc thiết lập các thuộc tính cần thiết cho view.
        this.title = "Chào mừng bạn đến với SPA của tôi!";
        this.description = "Đây là trang chủ. Bạn có thể điều hướng đến các trang khác bằng cách nhấp vào các liên kết ở trên.";
        this.note = "Ứng dụng này chỉ sử dụng Vanilla JavaScript ở phía frontend.";
    }

    // Phương thức để trả về nội dung HTML của trang
    // Tên phương thức thường là render() hoặc getContent()
    render() {
        return `
            <h1>${this.title}</h1>
            <p>${this.description}</p>
            <p>${this.note}</p>
        `;
    }

    // Bạn có thể thêm các phương thức khác ở đây để xử lý logic riêng của trang chủ,
    // ví dụ: attachEvents() để gắn các event listener cho các nút,
    // hoặc fetchData() nếu trang cần tải dữ liệu.
}
Cách cập nhật js/router.js để sử dụng HomePage class:
Bạn sẽ cần thay đổi cách nhập và sử dụng getHomePageContent thành HomePage.

JavaScript

// js/router.js

// Import các lớp View thay vì các hàm
import { HomePage } from './views/home.js'; // Thay đổi import
import { AboutPage } from './views/about.js'; // Giả sử bạn cũng dùng class cho AboutPage
import { ContactPage } from './views/contact.js'; // Giả sử bạn cũng dùng class cho ContactPage
import { getNotFoundPageContent } from './views/notFound.js'; // Hàm này vẫn là hàm đơn giản

// Hàm helper để in ra console
function tt(t) {
    console.log(t);
}

export class Router {
    constructor(appElement) {
        if (!appElement) {
            console.error("Router requires an app element to be provided.");
            return;
        }
        this.appElement = appElement;
        this.handleRouteBound = this.handleRoute.bind(this);
    }

    init() {
        window.addEventListener('hashchange', this.handleRouteBound);
        this.handleRouteBound();
    }

    handleRoute() {
        const hash = window.location.hash.substring(1);
        tt(hash);

        let content = '';

        switch (hash) {
            case 'home':
            case '':
                // Tạo một instance của HomePage và gọi phương thức render() của nó
                const homePage = new HomePage();
                content = homePage.render();
                break;
            case 'about':
                // Tương tự cho AboutPage nếu là class
                // const aboutPage = new AboutPage();
                // content = aboutPage.render();
                content = getAboutPageContent(); // Giữ nguyên nếu AboutPage vẫn là hàm
                break;
            case 'contact':
                // Tương tự cho ContactPage nếu là class
                // const contactPage = new ContactPage();
                // content = contactPage.render();
                content = getContactPageContent(); // Giữ nguyên nếu ContactPage vẫn là hàm
                break;
            default:
                content = getNotFoundPageContent();
                break;
        }

        this.appElement.innerHTML = content;
    }

    navigateTo(path) {
        window.location.hash = path;
    }
}
Ưu điểm của việc sử dụng class cho Views:

Đóng gói (Encapsulation): Toàn bộ logic và dữ liệu liên quan đến một view được gói gọn trong một lớp duy nhất.
Tái sử dụng: Nếu bạn có các phần tử UI phức tạp, bạn có thể tạo các phương thức trong class để quản lý chúng và tái sử dụng logic đó.
Quản lý trạng thái: Class có thể có các thuộc tính (this.data, this.state) để quản lý trạng thái nội bộ của view.
Thêm logic sự kiện: Bạn có thể thêm các phương thức như attachEvents() trong class của view để gắn các event listeners cụ thể cho các phần tử bên trong view đó, giúp giữ code sạch sẽ và tách biệt.
Dễ mở rộng: Bạn có thể kế thừa (inherit) từ một lớp BaseView chung để chia sẻ các phương thức và thuộc tính phổ biến giữa các view.
Khi nào nên dùng class cho Views và khi nào không:

Nên dùng class:
View có logic phức tạp (ví dụ: form validation, tương tác người dùng phức tạp).
View cần quản lý trạng thái riêng.
View cần tương tác với API để lấy dữ liệu.
Bạn muốn có một cấu trúc đồng nhất cho tất cả các "trang" hoặc "thành phần" của mình.
Không nhất thiết phải dùng class:
View chỉ đơn giản là trả về một chuỗi HTML tĩnh và không có logic tương tác nào. Trong trường hợp này, một hàm đơn giản (như getHomePageContent() ban đầu) là đủ và đơn giản hơn.
Đối với ví dụ hiện tại của bạn, việc sử dụng class cho HomePage có thể là quá mức, nhưng nó là một bước quan trọng để bạn hiểu cách tổ chức code theo hướng đối tượng trong JavaScript và chuẩn bị cho các ứng dụng phức tạp hơn.