# h7 giải thích Router

Được rồi, chúng ta hãy cùng phân tích lý do tại sao những thay đổi này là cần thiết và chúng giải quyết những vấn đề gì trong máy tính của bạn Router.jsvà cách chúng tương tác với main.js.

Vấn đề cốt lõi nằm ở thời gian liên quan đến thời điểm người nghe đăng ký so với thời điểm thay đổi tuyến đường ban đầu được kích hoạt.

Vấn đề với cách tiếp cận trước đây:
Trước khi thay đổi, giao diện của bạn Router.jstrông giống thế này (đã được đơn giản hóa):

JavaScript

// Old Router.js (simplified)
export class Router {
    constructor() {
        this.routeChangeListeners = [];
        this.init(); // <--- Calls init() immediately
    }

    init() {
        // Sets up popstate and click listeners
        // ...

        // IMMEDIATELY triggers initial route change
        const initialPath = window.location.pathname;
        this.#triggerRouteChange(initialPath); // <--- Problematic call for initial load
    }

    // ... #triggerRouteChange and onRouteChange methods ...
}

// In main.js (simplified)
document.addEventListener('DOMContentLoaded', () => {
    const routerInstance = new Router(); // Router.constructor and init() run here
    routerInstance.onRouteChange((path) => { /* update sidebar */ }); // <--- Listener registered AFTER init() runs
});
Nhược điểm:

Khi new Router()được gọi vào main.js, Router'đã constructorđược thực hiện this.init().
Bên trong init(), Routerngay lập tức được gọi đến this.#triggerRouteChange(initialPath).
Vào đúng thời điểm này, this.routeChangeListenersmảng bên trong Routerđang trống .
Tại sao lại rỗng? Bởi vì dòng routerInstance.onRouteChange((path) => { /* update sidebar */ });in main.jsvẫn chưa được thực thi . Nó chạy sau khi new Router() hoàn tất.
Vì vậy, đối với lần tải trang đầu tiên (khi URL là /), Routerđã kích hoạt sự kiện thay đổi tuyến đường trước khi bất kỳ ai (như của bạn Sidebar) lắng nghe nó. Phương thức Sidebar's updateActiveLinksđơn giản là không bao giờ được gọi cho URL ban đầu.

Giải pháp: Tách cài đặt Listener khỏi Trigger ban đầu
Để khắc phục điều này, chúng ta cần đảm bảo rằng tất cả các thành phần (như thành phần của bạn Sidebar) đều có cơ hội đăng ký trình lắng nghe trước khi Bộ định tuyến thông báo cho mọi người "Này, đây là đường dẫn ban đầu!"

Điều này đạt được bằng cách:

Đổi tên init()thành _setupListeners()(và làm cho nó trở nên "riêng tư"):

Cũ: init() là một phương thức công khai, được gọi ngay lập tức trong hàm tạo và thực hiện mọi thứ (thiết lập trình lắng nghe VÀ kích hoạt tuyến đường ban đầu). Cách tiếp cận nguyên khối này gây ra vấn đề về thời gian.
Mới ( _setupListeners()): Phương pháp này hiện chỉ tập trung vào việc thiết lập trình lắng nghe sự kiện của trình duyệt ( popstatecho các nút quay lại/tiến lên và clickcho data-linkđiều hướng).
Nó được gọi trong hàm tạo ( this._setupListeners()), do đó các trình lắng nghe điều hướng thiết yếu này luôn hoạt động ngay sau khi Routerđược tạo.
Theo quy ước, _tiền tố báo hiệu rằng đó là phương thức nội bộ, không dành cho các lệnh gọi trực tiếp bên ngoài sau khi xây dựng.
Tạo triggerInitialRoute()(một phương thức công khai mới):

Đây là phần bổ sung quan trọng. Phương pháp mới này đóng gói logic để xác định đường dẫn ban đầu ( window.location.pathname), hiển thị nội dung và sau đó, quan trọng là kích hoạt #triggerRouteChangethông báo.
Đây là phương thức công khai (không có _tiền tố) vì main.jscần phải gọi nó một cách rõ ràng.
Điều chỉnh main.jsthứ tự thực hiện:

JavaScript

// In main.js (New order)
document.addEventListener('DOMContentLoaded', () => {
    // ... render Header and Sidebar ...

    const routerInstance = new Router(); // Router is created, _setupListeners() runs (listeners are now active)

    // NOW, register the Sidebar's listener with the Router
    routerInstance.onRouteChange((path) => {
        sidebarInstance.updateActiveLinks(path);
    });

    // FINALLY, tell the Router to trigger the initial route change
    routerInstance.triggerInitialRoute(); // <-- This now correctly notifies the already-registered Sidebar
});
Tại sao cần có những chức năng cụ thể này:
_setupListeners(): Để đảm bảo rằng các trình lắng nghe sự kiện cơ bản của trình duyệt để định tuyến (clicks, popstate) luôn hoạt động ngay khi đối tượng bộ định tuyến tồn tại. Các trình lắng nghe này dành cho các sự kiện điều hướng trong tương lai .
triggerInitialRoute(): Để kiểm soát rõ ràng thời điểm Bộ định tuyến thông báo cho phần còn lại của ứng dụng về URL ban đầu mà người dùng đã truy cập. Bằng cách biến nó thành một phương thức công khai riêng biệt được gọi sau khi tất cả các thành phần đã đăng ký trình lắng nghe của chúng, chúng tôi đảm bảo rằng mọi người đều sẵn sàng nhận thông tin tuyến đường ban đầu.
Sự tách biệt các mối quan tâm này giúp ứng dụng của bạn Routermạnh mẽ và dễ dự đoán hơn, cho phép các mô-đun bên ngoài (như main.js) sắp xếp luồng khởi động của ứng dụng một cách chính xác.