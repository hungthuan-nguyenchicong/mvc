# h6

Bạn đã đưa ra một nhận xét rất hay! Bạn hoàn toàn đúng khi cho rằng Sidebarthành phần nên tập trung vào việc quản lý các lớp riêng của nó cho các trạng thái "hoạt động" và "hoạt động của cha mẹ" và rằng nó cần phản hồi chính xác khi lịch sử của trình duyệt thay đổi (tức là khi người dùng quay lại hoặc tiến lên).

Trình popstatelắng nghe sự kiện bạn thêm vào Sidebarlà một khởi đầu tốt, nhưng nó chỉ xóa các lớp. Nó không thêm các lớp chính xác cho đường dẫn mới (hiện tại).

Tại sao Cập nhật tập trung tốt hơn
Thay vì Sidebarlắng nghe trực tiếp popstatevà clickcác sự kiện để cập nhật trạng thái của nó, Router sẽ mạnh mẽ và sạch sẽ hơn khi là nguồn duy nhất cung cấp sự thật cho các thay đổi tuyến đường. Router đã biết đường dẫn hiện tại, cho dù đó là từ a pushStatehay popstateevent.

Sau đây là lý do và cách tinh chỉnh Sidebartương tác của bạn và nó với Router:

Nguồn sự thật duy nhất: Đang Routerquản lý history.pushStatevà phản ứng với popstate. Đây là nơi lý tưởng để thông báo cho bất kỳ thành phần nào quan tâm (như của bạn Sidebar) về đường dẫn hiện tại mới .
Tránh trùng lặp: Nếu Sidebarcũng xử lý trực tiếp popstateđể cập nhật các lớp của nó và Routercũng xử lý việc này để hiển thị nội dung, bạn đang trùng lặp logic và khiến việc bảo trì trở nên khó khăn hơn.
Tính chính xác: Bằng cách Routercho biết , bạn đảm bảo rằng Sidebarluôn cập nhật để phản ánh tuyến đường thực tế mà nội dung đang hiển thị.currentPathSidebar
Đã sửa đổi Sidebar.jsvà tương tác bộ định tuyến
Hãy điều chỉnh Sidebarđể loại bỏ popstatetrình lắng nghe trực tiếp của nó và giới thiệu một phương thức chuyên dụng ( updateActiveLinks) mà nó Routersẽ gọi. Điều này làm cho Sidebarthành phần trở nên "ngu ngốc" về mặt logic định tuyến, chỉ phản ứng khi được yêu cầu.

JavaScript

// src/components/Sidebar.js
import './Sidebar.scss';

export class Sidebar {
    constructor() {
        this.sidebarElement = null;
        this.navLinks = null; // Store navLinks after rendering for efficiency
    }

    render() {
        this.sidebarElement = document.createElement('aside');
        this.sidebarElement.innerHTML = /* html */ `
            <ul>
                <li><a href="/" class="nav-link" data-link>Dashboard</a></li>
                <hr>
                <li>
                    <a href="/posts" class="nav-link" data-link>Tất cả Bài viết</a>
                    <ul>
                        <li><a href="/post/create" data-link>Thêm Mới</a></li>
                        <li><a href="/category/post" data-link>Danh mục bài viết</a></li>
                    </ul>
                </li>
                <hr>
                <li>
                    <a href="/product" class="nav-link" data-link>Tất cả Sản Phẩm</a>
                    <ul>
                        <li><a href="/product/create" data-link>Thêm Mới</a></li>
                        <li><a href="/category/product" data-link>Danh mục Sản phẩm</a></li>
                    </ul>
                </li>
                <hr>
                <li><a href="/settings" class="nav-link" data-link>Cài đặt</a></li>
                <hr>
                <li><a href="/logout" class="nav-link" data-link>Logout</a></li>
            </ul>
        `;
        return this.sidebarElement;
    }

    // This method will be called by the Router to update active links
    updateActiveLinks(currentPath) {
        if (!this.sidebarElement) {
            console.warn("Sidebar element not rendered yet. Cannot update active links.");
            return;
        }

        // Query navLinks only once after rendering or if not already set
        if (!this.navLinks) {
            this.navLinks = this.sidebarElement.querySelectorAll('a[data-link]');
        }

        // 1. Remove all 'active' and 'parent-active' classes from all links
        this.navLinks.forEach(navLink => {
            navLink.classList.remove('active');
            navLink.classList.remove('parent-active');
        });

        // 2. Find and add 'active'/'parent-active' based on the currentPath
        this.navLinks.forEach(link => {
            const linkHref = link.getAttribute('href');

            // Exact match for 'active' class
            if (linkHref === currentPath) {
                link.classList.add('active');
                // If it's a sub-link, also activate its parent category link
                const parentUl = link.closest('ul ul');
                if (parentUl) {
                    const parentLink = parentUl.previousElementSibling; // The <a> immediately before the nested <ul>
                    if (parentLink && parentLink.matches('a[data-link]')) {
                        parentLink.classList.add('parent-active');
                    }
                }
            }
            // For parent links that match a prefix of the current path
            // e.g., /posts should be parent-active when /posts/create is currentPath
            // Avoid activating '/' as parent-active for all routes
            else if (currentPath.startsWith(linkHref + '/') && linkHref !== '/') {
                 link.classList.add('parent-active');
            }
        });

        // Special handling for the root '/' path
        // Ensure Dashboard is active only when exactly on '/'
        if (currentPath === '/') {
            const dashboardLink = this.sidebarElement.querySelector('a[href="/"]');
            if (dashboardLink) {
                dashboardLink.classList.add('active');
            }
        }
    }

    // Remove direct event listeners that manage active classes.
    // The Router's global click listener will handle navigation,
    // and then call updateActiveLinks via its onRouteChange mechanism.
    // So, this method doesn't need to do anything with 'click' events.
    addEventListeners() {
        // No event listeners needed here for active class management
        // The Router will notify us when a route changes, and we'll update then.
        // You might add other event listeners here for sidebar-specific UI
        // interactions that don't involve routing, e.g., expanding/collapsing menus.
    }
}
Vai trò của bộ định tuyến (từ thảo luận trước)
Sau đó, giao diện của bạn Routersẽ trông như thế này, đảm bảo nó gọi updateActiveLinksđến bất kỳ thay đổi tuyến đường nào:

JavaScript

// src/core/Router.js (Simplified for focus)
// ... (renderContent function remains the same) ...

export class Router {
    constructor() {
        this.routeChangeListeners = []; // Array to hold functions to call on route change
        this.init();
    }

    onRouteChange(callback) {
        if (typeof callback === 'function') {
            this.routeChangeListeners.push(callback);
        }
    }

    #triggerRouteChange(path) {
        this.routeChangeListeners.forEach(listener => listener(path));
    }

    init() {
        window.addEventListener('popstate', () => {
            const currentPath = window.location.pathname;
            renderContent(currentPath);
            this.#triggerRouteChange(currentPath); // Notify Sidebar
        });

        document.body.addEventListener('click', (e) => {
            const routeLink = e.target.closest('a[data-link]');
            if (routeLink) {
                e.preventDefault();
                const path = routeLink.getAttribute('href');

                if (window.location.pathname === path) {
                    this.#triggerRouteChange(path); // Still notify for potential UI update even if path is same
                    return;
                }

                history.pushState(null, '', path);
                renderContent(path);
                this.#triggerRouteChange(path); // Notify Sidebar
            }
        });

        const initialPath = window.location.pathname;
        renderContent(initialPath);
        this.#triggerRouteChange(initialPath); // Initial notification
    }
}
Những gì đã thay đổi và tại sao:
Sidebar.addEventListeners(): Phương pháp này hiện không có logic liên quan đến định tuyến. Mục đích duy nhất của nó là dành cho các tương tác UI không định tuyến dành riêng cho thanh bên (ví dụ: nút "chuyển đổi" cho chính thanh bên).
Sidebar.updateActiveLinks(currentPath): Đây là phương thức công khai mới chịu trách nhiệm cập nhật trạng thái hoạt động của thanh bên. Nó rõ ràng lấy the currentPathlàm đối số.
Không có Direct popstatetrong Sidebar: Không Sidebarcòn lắng nghe popstatetrực tiếp nữa. Nó hoàn toàn dựa vào Routerđể cho biết khi nào đường dẫn thay đổi.
Logic Parent-Active được cải thiện: Bây updateActiveLinksgiờ có logic mạnh mẽ hơn để xử lý khi một mục menu "cha" (như "Tất cả Bài viết") phải được đánh dấu là parent-activengay cả khi một tuyến con (như /post/create) là đường dẫn hiện tại. Nó cũng xử lý /liên kết (Bảng điều khiển) một cách chính xác để tránh liên kết này activekhi các tuyến con khác đang hoạt động.
navLinkslưu trữ đệm: Bây giờ chúng navLinksđược truy vấn và lưu trữ trong constructor(hoặc trong updateActiveLinks) để tránh truy vấn lại DOM trên mỗi lần thay đổi tuyến đường, cải thiện hiệu suất đôi chút.
Phương pháp tinh tế này cung cấp khả năng phân tách rõ ràng hơn các mối quan tâm, giúp bộ định tuyến của bạn tập trung hơn và thanh bên phản ứng nhanh hơn, ít bị phụ thuộc vào các sự kiện trực tiếp của trình duyệt.