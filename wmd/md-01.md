# hoc 01

Bạn đã đưa ra một bản phác thảo rất chi tiết và đầy đủ cho việc xây dựng một Admin Dashboard sử dụng PHP MVC code thuần (cho Backend API) và Vanilla JS SPA code thuần (cho Frontend). Đây là một cách tiếp cận tuyệt vời để hiểu sâu sắc về kiến trúc và cách hoạt động của một ứng dụng web hiện đại.

Dưới đây là một số điểm tổng kết và gợi ý bổ sung dựa trên những gì bạn đã trình bày, nhằm giúp bạn (hoặc người đọc) có cái nhìn toàn diện hơn và dễ dàng triển khai:

Tóm Tắt Kiến Trúc Ứng Dụng
Ứng dụng của bạn được thiết kế theo mô hình tách biệt giữa Backend (API) và Frontend (SPA), giao tiếp thông qua JSON.

PHP MVC Backend (Controller -> JSON)
Mục tiêu: Xây dựng một API RESTful để cung cấp dữ liệu cho frontend.
Cấu trúc: Sử dụng mô hình HMVC/Modular MVC để tổ chức code backend thành các module (ví dụ: Users, Products).
Thành phần chính:
public/index.php: Điểm vào duy nhất của ứng dụng, chịu trách nhiệm khởi tạo các thành phần cốt lõi và dispatch request.
app/init.php: Khởi tạo autoloader và kết nối cơ sở dữ liệu.
app/Core/: Chứa các lớp lõi như Router, Request, Response, Database, Controller cơ sở.
app/Modules/{ModuleName}/: Nơi chứa Controller và Model cụ thể cho từng module (ví dụ Users, Products).
Luồng hoạt động:
Request HTTP (GET, POST, PUT, DELETE) từ frontend đến index.php.
Router phân tích URI và method, sau đó điều hướng đến Controller và Action tương ứng trong module.
Controller xử lý logic nghiệp vụ, gọi Model để tương tác với cơ sở dữ liệu.
Model thực hiện các truy vấn CSDL (sử dụng PDO).
Controller trả về dữ liệu dưới dạng JSON thông qua lớp Response.
Vanilla JS SPA Frontend (Admin Dashboard)
Mục tiêu: Xây dựng một giao diện người dùng động, tương tác cao mà không cần tải lại trang.
Cấu trúc: Tổ chức code JavaScript thành các file riêng biệt cho Router, API calls, Components và Pages.
Thành phần chính:
public/index.html: File HTML chính, là "khung xương" của SPA.
public/js/main.js: File khởi tạo SPA, định nghĩa các route frontend.
public/js/router.js: Quản lý định tuyến trong SPA (sử dụng History API).
public/js/api.js: Chứa các hàm để gọi API backend (sử dụng fetch API).
public/js/components/: Các thành phần UI có thể tái sử dụng (ví dụ: UserList, UserForm).
public/js/pages/: Các trang chính của ứng dụng (ví dụ: UsersPage, DashboardPage).
Luồng hoạt động:
Người dùng tương tác với giao diện (nhấp link, gửi form).
Router (frontend) chặn hành vi mặc định của link, cập nhật URL trình duyệt (mà không tải lại trang), và quyết định render page/component nào.
Page/Component gọi các hàm trong api.js để gửi request đến backend API.
Nhận dữ liệu JSON từ backend, Page/Component cập nhật nội dung của #content trong index.html bằng cách thao tác trực tiếp với DOM.
Gắn lại các sự kiện (event listeners) cho các phần tử DOM mới được render.
Gợi Ý và Bước Triển Khai Tiếp Theo
Bạn đã cung cấp một nền tảng vững chắc. Để hoàn thiện và làm cho dự án này trở nên thực tế hơn, hãy xem xét các điểm sau:

1. Triển Khai Database và Cấu Hình
Tạo Database: Đảm bảo bạn đã tạo một database MySQL (hoặc PostgreSQL, SQLite) và bảng users với các cột id, name, email, password.
SQL

CREATE DATABASE IF NOT EXISTS `admin_dashboard_db`;
USE `admin_dashboard_db`;

CREATE TABLE IF NOT EXISTS `users` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `name` VARCHAR(255) NOT NULL,
    `email` VARCHAR(255) UNIQUE NOT NULL,
    `password` VARCHAR(255) NOT NULL,
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
Cấu hình app/config/database.php:
PHP

<?php
define('DB_HOST', 'localhost');
define('DB_NAME', 'admin_dashboard_db');
define('DB_USER', 'root'); // Thay bằng user của bạn
define('DB_PASS', '');     // Thay bằng password của bạn
Thiết lập Web Server: Đảm bảo Apache (hoặc Nginx) được cấu hình để trỏ public là thư mục gốc của dự án và cho phép mod_rewrite để xử lý các URL thân thiện.
2. Phát Triển Thêm Các Module và Component
UserForm Component (public/js/components/UserForm.js):
Tạo form để thêm mới và chỉnh sửa người dùng.
Xử lý việc lấy dữ liệu người dùng hiện có khi ở chế độ chỉnh sửa.
Gửi dữ liệu form đến API backend (sử dụng UsersAPI.create hoặc UsersAPI.update).
Quản lý thông báo lỗi/thành công cho người dùng.
DashboardPage (public/js/pages/DashboardPage.js): Một trang đơn giản hiển thị thông tin tổng quan.
Products Module/Components: Lặp lại quy trình tương tự cho module Products (Backend: ProductController.php, Product.php; Frontend: ProductList.js, ProductForm.js, ProductsPage.js).
3. Xử Lý Lỗi và Thông Báo
Backend: Cải thiện việc trả về thông báo lỗi chi tiết hơn từ Controller khi có lỗi xảy ra (ví dụ: lỗi validation, lỗi CSDL).
Frontend: Hiển thị các thông báo lỗi hoặc thành công rõ ràng cho người dùng (ví dụ: dùng alert đơn giản, hoặc phát triển một hệ thống toast/snackbar message).
4. Xác Thực và Ủy Quyền (Authentication & Authorization)
Đây là một phần quan trọng của Admin Dashboard.

Backend:
Thêm một AuthController.php để xử lý đăng nhập/đăng ký.
Khi đăng nhập thành công, tạo và trả về một JWT (JSON Web Token) cho client.
Triển khai một Middleware hoặc logic kiểm tra token trong Router hoặc Controller cơ sở để bảo vệ các API endpoint cần xác thực.
Frontend:
Xây dựng trang đăng nhập.
Khi nhận được JWT từ backend, lưu trữ nó (ví dụ: localStorage.setItem('jwt', token)).
Trong api.js, thêm token vào header Authorization: Bearer <token> cho mỗi request đến các API được bảo vệ.
Triển khai logic kiểm tra token khi khởi tạo ứng dụng và chuyển hướng người dùng đến trang đăng nhập nếu chưa được xác thực.
5. Tối Ưu Hóa và Mở Rộng
Validation:
Backend: Triển khai server-side validation trong Controllers hoặc trong Models để đảm bảo dữ liệu hợp lệ trước khi lưu vào DB.
Frontend: Triển khai client-side validation để cung cấp phản hồi tức thì cho người dùng.
Phân trang (Pagination): Nếu danh sách dữ liệu lớn, triển khai phân trang ở cả backend (truy vấn CSDL có LIMIT/OFFSET) và frontend (UI điều hướng trang).
Tìm kiếm & Lọc: Thêm chức năng tìm kiếm và lọc dữ liệu.
Code Organization (Frontend): Khi dự án lớn, xem xét cấu trúc module/component phức tạp hơn, có thể dùng các thư viện nhỏ để quản lý trạng thái nếu cần.
CSS Framework: Để tăng tốc độ phát triển UI, bạn có thể tích hợp một framework CSS như Bootstrap hoặc Tailwind CSS.
Bắt đầu bằng cách làm cho ví dụ Users chạy hoàn chỉnh (CRUD - Create, Read, Update, Delete) trên cả backend và frontend. Sau đó, áp dụng các nguyên tắc tương tự cho các module khác và bổ sung các tính năng nâng cao. Việc xây dựng từ code thuần sẽ mang lại cho bạn kiến thức nền tảng vững chắc, rất có giá trị khi bạn chuyển sang sử dụng các framework lớn hơn sau này.


Nguồn






bạn có thể hướng đẫn tôi các file trên . bắt đầu từ khởi tại và code từng file một từ cơ bản đến nâng cao


Tuyệt vời! Chúng ta sẽ đi từng bước để xây dựng Admin Dashboard bằng PHP MVC thuần cho backend và Vanilla JS SPA cho frontend, bắt đầu từ những điều cơ bản nhất. Việc này sẽ giúp bạn nắm vững từng khái niệm.

1. Chuẩn Bị Môi Trường
Trước khi bắt đầu code, bạn cần đảm bảo môi trường phát triển của mình đã sẵn sàng:

Web Server: Cài đặt Apache hoặc Nginx.
PHP: Cài đặt PHP (phiên bản 7.4 trở lên là tốt nhất) cùng với các extension cần thiết như php-pdo_mysql (hoặc php-pdo cho database bạn chọn).
Database: Cài đặt MySQL (hoặc MariaDB, PostgreSQL).
Editor Code: Visual Studio Code, Sublime Text, PhpStorm, v.v.
Cấu hình Virtual Host (cho Apache)

Để ứng dụng của bạn chạy mượt mà, bạn nên tạo một Virtual Host. Ví dụ, nếu bạn muốn truy cập ứng dụng qua http://dashboard.local, bạn sẽ thêm cấu hình sau vào file cấu hình Apache (ví dụ: httpd-vhosts.conf trên XAMPP/WAMP hoặc trong thư mục sites-available trên Linux):

Apache

<VirtualHost *:80>
    DocumentRoot "C:/path/to/your/project/public"
    ServerName dashboard.local

    <Directory "C:/path/to/your/project/public">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog "logs/dashboard.local-error.log"
    CustomLog "logs/dashboard.local-access.log" common
</VirtualHost>
Nhớ thay đổi "C:/path/to/your/project" thành đường dẫn thực tế đến thư mục dự án của bạn.
Sau đó, thêm dòng sau vào file hosts của hệ điều hành (thường là C:\Windows\System32\drivers\etc\hosts trên Windows hoặc /etc/hosts trên Linux/macOS):

127.0.0.1 dashboard.local
Khởi động lại Apache sau khi thay đổi cấu hình.

2. Cấu Trúc Thư Mục Cơ Bản
Chúng ta sẽ tạo cấu trúc thư mục như đã định nghĩa. Trong thư mục gốc của dự án (ví dụ: admin-dashboard), hãy tạo các thư mục và file sau:

admin-dashboard/
├── public/                 // Chứa điểm vào ứng dụng và tài nguyên tĩnh
│   ├── css/
│   │   └── style.css
│   ├── js/
│   │   ├── api.js
│   │   ├── router.js
│   │   ├── main.js
│   │   ├── components/
│   │   │   ├── UserList.js
│   │   │   └── UserForm.js
│   │   └── pages/
│   │       ├── DashboardPage.js
│   │       ├── UsersPage.js
│   │       └── ProductsPage.js
│   ├── .htaccess           // Quy tắc Rewrite URL cho Apache
│   └── index.php           // Điểm vào chính của ứng dụng PHP
├── app/                    // Chứa mã nguồn PHP của ứng dụng
│   ├── Core/               // Các lớp lõi
│   │   ├── Controller.php
│   │   ├── Database.php
│   │   ├── Request.php
│   │   ├── Response.php
│   │   └── Router.php
│   ├── Models/             // Các lớp Model chung (có thể bỏ qua với HMVC)
│   ├── Modules/            // Các Module (HMVC)
│   │   ├── Users/
│   │   │   ├── UserController.php
│   │   │   └── User.php    // Model cho module Users
│   │   └── Products/
│   │       ├── ProductController.php
│   │       └── Product.php // Model cho module Products
│   ├── config/             // Các file cấu hình
│   │   └── database.php
│   └── init.php            // File khởi tạo ứng dụng PHP
└── README.md
3. Khởi Tạo Database
Chúng ta cần tạo database và bảng users để lưu trữ thông tin người dùng.
Mở công cụ quản lý CSDL của bạn (phpMyAdmin, MySQL Workbench, DBeaver, HeidiSQL, hoặc terminal) và chạy các câu lệnh SQL sau:

SQL

-- Tạo database nếu chưa tồn tại
CREATE DATABASE IF NOT EXISTS `admin_dashboard_db`;

-- Chọn database để sử dụng
USE `admin_dashboard_db`;

-- Tạo bảng users
CREATE TABLE IF NOT EXISTS `users` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `name` VARCHAR(255) NOT NULL,
    `email` VARCHAR(255) UNIQUE NOT NULL,
    `password` VARCHAR(255) NOT NULL,
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Thêm một vài dữ liệu mẫu (tùy chọn)
-- Mật khẩu "password123" được mã hóa (bạn sẽ cần mã hóa trong code PHP)
-- Đây chỉ là ví dụ, trong thực tế bạn sẽ hash bằng PHP
INSERT INTO `users` (`name`, `email`, `password`) VALUES
('Alice Smith', 'alice@example.com', '$2y$10$wN1Q/t.n.m.L0u1z/E7WSu.1.2.3.4.5.6.7.8.9.0.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z'), -- password123 hashed
('Bob Johnson', 'bob@example.com', '$2y$10$wN1Q/t.n.m.L0u1z/E7WSu.1.2.3.4.5.6.7.8.9.0.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.Y.Z'); -- password123 hashed
Lưu ý: Mã hóa mật khẩu trong dữ liệu mẫu trên chỉ mang tính minh họa. Trong PHP, bạn sẽ sử dụng password_hash() để tạo ra mật khẩu đã mã hóa an toàn.

4. Bắt Đầu Code Backend (PHP MVC)
Chúng ta sẽ đi từ các file cấu hình, core, sau đó đến module.

4.1. Cấu hình Database (app/config/database.php)
Tạo file này để lưu trữ thông tin kết nối database.

PHP

<?php
// app/config/database.php

define('DB_HOST', 'localhost'); // Host của database (thường là localhost)
define('DB_NAME', 'admin_dashboard_db'); // Tên database bạn đã tạo
define('DB_USER', 'root');     // Tên người dùng database của bạn
define('DB_PASS', '');         // Mật khẩu database của bạn
4.2. File Khởi Tạo (app/init.php)
File này sẽ khởi động autoloader và load các cấu hình ban đầu.

PHP

<?php
// app/init.php

// 1. Autoloader đơn giản cho namespace App
spl_autoload_register(function ($class) {
    // Thay thế dấu gạch chéo ngược trong namespace bằng dấu gạch chéo thư mục
    // và nối với đường dẫn gốc của ứng dụng
    $file = __DIR__ . '/' . str_replace('\\', '/', $class) . '.php';

    // Kiểm tra xem file có tồn tại không trước khi require
    if (file_exists($file)) {
        require_once $file;
    }
});

// 2. Load cấu hình database
require_once __DIR__ . '/config/database.php';

// 3. Kết nối CSDL ngay khi ứng dụng khởi tạo
// Sử dụng namespace đầy đủ cho lớp Database
use App\Core\Database;

// Gọi phương thức tĩnh getInstance để khởi tạo kết nối database
// Các tham số được lấy từ file config/database.php
Database::getInstance(DB_HOST, DB_NAME, DB_USER, DB_PASS);
Giải thích:

spl_autoload_register(): Tự động nạp các lớp khi chúng được sử dụng lần đầu tiên, dựa trên namespace. Ví dụ: khi bạn dùng new App\Core\Router(), autoloader sẽ tìm file app/Core/Router.php.
4.3. Các Lớp Core
app/Core/Database.php
Lớp này quản lý kết nối PDO đến database, sử dụng pattern Singleton để chỉ có một instance kết nối duy nhất.

PHP

<?php
// app/Core/Database.php
namespace App\Core;

use PDO;
use PDOException;

class Database
{
    private static $instance = null; // Biến tĩnh để lưu trữ instance của Database
    private $connection; // Biến để lưu trữ đối tượng kết nối PDO

    // Constructor là private để ngăn tạo instance trực tiếp từ bên ngoài
    private function __construct($host, $db_name, $username, $password)
    {
        try {
            // Khởi tạo kết nối PDO
            $this->connection = new PDO("mysql:host=$host;dbname=$db_name;charset=utf8", $username, $password);
            // Thiết lập chế độ báo lỗi cho PDO
            $this->connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            // Thiết lập chế độ fetch mặc định là associative array
            $this->connection->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
        } catch (PDOException $e) {
            // Xử lý lỗi kết nối database
            die("Database connection failed: " . $e->getMessage());
        }
    }

    // Phương thức tĩnh để lấy instance của Database (Singleton pattern)
    public static function getInstance($host, $db_name, $username, $password)
    {
        if (!self::$instance) {
            // Nếu chưa có instance, tạo một instance mới
            self::$instance = new Database($host, $db_name, $username, $password);
        }
        return self::$instance; // Trả về instance duy nhất
    }

    // Phương thức để lấy đối tượng kết nối PDO
    public function getConnection()
    {
        return $this->connection;
    }
}
Giải thích:

Singleton Pattern: Đảm bảo chỉ có một kết nối database được tạo trong suốt vòng đời của ứng dụng, giúp tiết kiệm tài nguyên.
app/Core/Request.php
Lớp này đóng gói các thông tin từ HTTP request (URI, method, body, query params).

PHP

<?php
// app/Core/Request.php
namespace App\Core;

class Request
{
    // Lấy URI hiện tại của request (đường dẫn sau domain)
    public function getUri()
    {
        // parse_url giúp lấy chỉ phần path, loại bỏ query string
        // Ví dụ: /api/users?page=1 -> /api/users
        return parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
    }

    // Lấy HTTP method của request (GET, POST, PUT, DELETE)
    public function getMethod()
    {
        return $_SERVER['REQUEST_METHOD'];
    }

    // Lấy dữ liệu từ body của request (cho POST, PUT)
    public function getBody()
    {
        $body = [];
        if ($this->getMethod() === 'POST' || $this->getMethod() === 'PUT' || $this->getMethod() === 'PATCH') {
            // Kiểm tra Content-Type để xử lý JSON hoặc form-data
            $contentType = $_SERVER['CONTENT_TYPE'] ?? '';
            if (strpos($contentType, 'application/json') !== false) {
                // Nếu là JSON, đọc từ php://input và decode
                $body = json_decode(file_get_contents('php://input'), true);
            } else {
                // Nếu là form-data, sử dụng $_POST
                $body = $_POST;
            }
        }
        return $body;
    }

    // Lấy dữ liệu từ query string (GET parameters)
    public function query($key = null)
    {
        if ($key) {
            // Lấy giá trị của một key cụ thể, trả về null nếu không tồn tại
            return $_GET[$key] ?? null;
        }
        return $_GET; // Trả về tất cả các query parameters
    }

    // Lấy dữ liệu từ tham số URI được Router match (ví dụ /users/{id})
    // Phương thức này sẽ được set bởi Router sau khi match route
    public function setParams(array $params)
    {
        $this->params = $params;
    }

    public function params($key = null)
    {
        if ($key) {
            return $this->params[$key] ?? null;
        }
        return $this->params ?? [];
    }
}
Giải thích:

php://input: Dòng này đọc raw data từ request body, rất hữu ích cho các request JSON (thường dùng trong RESTful API).
app/Core/Response.php
Lớp này giúp bạn gửi HTTP response, đặc biệt là JSON.

PHP

<?php
// app/Core/Response.php
namespace App\Core;

class Response
{
    // Gửi phản hồi JSON
    public function json($data, $statusCode = 200)
    {
        // Đặt header Content-Type là application/json
        header('Content-Type: application/json');
        // Đặt HTTP status code
        http_response_code($statusCode);
        // Mã hóa dữ liệu thành JSON và in ra
        echo json_encode($data);
        // Dừng script để không có nội dung nào khác được gửi đi
        exit();
    }

    // Chuyển hướng trình duyệt
    public function redirect($url, $statusCode = 302)
    {
        header("Location: " . $url, true, $statusCode);
        exit();
    }

    // Gửi mã lỗi HTTP
    public function abort($statusCode = 404, $message = 'Not Found')
    {
        http_response_code($statusCode);
        die($message);
    }
}
app/Core/Controller.php
Lớp cơ sở cho tất cả các Controller khác. Nó cung cấp các instance của Request và Response và một helper để trả về JSON.

PHP

<?php
// app/Core/Controller.php
namespace App\Core;

class Controller
{
    protected $request;  // Đối tượng Request để truy cập dữ liệu request
    protected $response; // Đối tượng Response để gửi phản hồi

    public function __construct()
    {
        // Khởi tạo các đối tượng Request và Response khi một Controller được tạo
        $this->request = new Request();
        $this->response = new Response();
    }

    // Helper method để trả về JSON response một cách tiện lợi
    protected function json($data, $statusCode = 200)
    {
        $this->response->json($data, $statusCode);
    }

    // Helper method để chuyển hướng
    protected function redirect($url, $statusCode = 302)
    {
        $this->response->redirect($url, $statusCode);
    }
}
app/Core/Router.php
Lớp này quản lý việc định tuyến các URL đến Controller và Action tương ứng.

PHP

<?php
// app/Core/Router.php
namespace App\Core;

class Router
{
    protected $routes = []; // Mảng chứa tất cả các route đã đăng ký

    // Thêm một route vào danh sách
    public function addRoute($method, $path, $callback)
    {
        $this->routes[] = ['method' => $method, 'path' => $path, 'callback' => $callback];
    }

    // Các phương thức tiện lợi để đăng ký route theo HTTP method
    public function get($path, $callback) { $this->addRoute('GET', $path, $callback); }
    public function post($path, $callback) { $this->addRoute('POST', $path, $callback); }
    public function put($path, $callback) { $this->addRoute('PUT', $path, $callback); }
    public function delete($path, $callback) { $this->addRoute('DELETE', $path, $callback); }

    // Xử lý và điều phối request đến Controller/Action phù hợp
    public function dispatch(Request $request, Response $response)
    {
        $uri = $request->getUri(); // Lấy URI hiện tại
        $method = $request->getMethod(); // Lấy HTTP method

        foreach ($this->routes as $route) {
            // Biến đổi route path (ví dụ: /users/{id}) thành regex pattern
            // {([a-zA-Z0-9_]+)} sẽ khớp với bất kỳ chuỗi nào và bắt nó vào nhóm
            $pattern = preg_replace('/\{([a-zA-Z0-9_]+)\}/', '([a-zA-Z0-9_]+)', $route['path']);
            // Thêm dấu ^ và $ để đảm bảo khớp toàn bộ chuỗi URI
            $pattern = '#^' . $pattern . '$#';

            // Kiểm tra nếu HTTP method khớp VÀ URI khớp với pattern regex
            if ($route['method'] === $method && preg_match($pattern, $uri, $matches)) {
                array_shift($matches); // Loại bỏ phần tử đầu tiên (full match của regex)

                // Tách Controller và Action từ callback (ví dụ: 'Users@index')
                list($controllerName, $actionName) = explode('@', $route['callback']);

                // Xây dựng đường dẫn file của Controller
                // Ví dụ: app/Modules/Users/UserController.php
                $controllerFile = __DIR__ . '/../Modules/' . $controllerName . '/' . $controllerName . 'Controller.php';
                // Xây dựng tên lớp Controller đầy đủ với namespace
                // Ví dụ: App\Modules\Users\UserController
                $controllerClass = 'App\\Modules\\' . $controllerName . '\\' . $controllerName . 'Controller';

                // Kiểm tra nếu file Controller tồn tại
                if (file_exists($controllerFile)) {
                    require_once $controllerFile; // Nạp file Controller
                    $controller = new $controllerClass(); // Tạo instance của Controller

                    // Kiểm tra nếu action method tồn tại trong Controller
                    if (method_exists($controller, $actionName)) {
                        // Gọi action method với các tham số đã bắt được từ URI
                        call_user_func_array([$controller, $actionName], $matches);
                        return; // Dừng xử lý sau khi đã tìm thấy và xử lý route
                    }
                }
            }
        }

        // Nếu không tìm thấy route nào khớp, trả về lỗi 404 Not Found
        $response->json(['message' => 'Not Found'], 404);
    }
}
Giải thích:

Regex for Parameters: Sử dụng preg_replace để biến đổi các placeholder như {id} thành các nhóm bắt regex ([a-zA-Z0-9_]+), giúp trích xuất tham số từ URL.
call_user_func_array(): Gọi phương thức của một đối tượng với một mảng các tham số, rất tiện lợi khi bạn có tham số động từ URL.
4.4. Module Users
app/Modules/Users/User.php (Model)
Model này sẽ tương tác trực tiếp với bảng users trong database.

PHP

<?php
// app/Modules/Users/User.php
namespace App\Modules\Users;

use App\Core\Database; // Import lớp Database
use PDO;
use PDOException; // Import PDOException để xử lý lỗi CSDL

class User
{
    private $conn; // Biến để lưu trữ đối tượng kết nối PDO
    private $table_name = "users"; // Tên bảng trong database

    public function __construct()
    {
        // Lấy kết nối database thông qua Singleton pattern
        $this->conn = Database::getInstance(DB_HOST, DB_NAME, DB_USER, DB_PASS)->getConnection();
    }

    // Lấy tất cả người dùng
    public function getAllUsers()
    {
        $query = "SELECT id, name, email FROM " . $this->table_name;
        try {
            $stmt = $this->conn->prepare($query);
            $stmt->execute();
            return $stmt->fetchAll(PDO::FETCH_ASSOC); // Trả về mảng kết hợp
        } catch (PDOException $e) {
            error_log("Error in getAllUsers: " . $e->getMessage()); // Ghi log lỗi
            return []; // Trả về mảng rỗng nếu có lỗi
        }
    }

    // Lấy người dùng theo ID
    public function getUserById($id)
    {
        $query = "SELECT id, name, email FROM " . $this->table_name . " WHERE id = :id LIMIT 0,1";
        try {
            $stmt = $this->conn->prepare($query);
            $stmt->bindParam(':id', $id, PDO::PARAM_INT); // Bind param với kiểu INT
            $stmt->execute();
            return $stmt->fetch(PDO::FETCH_ASSOC); // Trả về một hàng kết quả
        } catch (PDOException $e) {
            error_log("Error in getUserById: " . $e->getMessage());
            return null;
        }
    }

    // Tạo người dùng mới
    public function createUser($data)
    {
        // Yêu cầu ít nhất name, email, password
        if (!isset($data['name']) || !isset($data['email']) || !isset($data['password'])) {
            return false;
        }

        $query = "INSERT INTO " . $this->table_name . " (name, email, password) VALUES (:name, :email, :password)";
        try {
            $stmt = $this->conn->prepare($query);

            // Xử lý dữ liệu đầu vào: loại bỏ các ký tự HTML nguy hiểm
            $name = htmlspecialchars(strip_tags($data['name']));
            $email = htmlspecialchars(strip_tags($data['email']));
            // Mã hóa mật khẩu trước khi lưu vào database
            $password = password_hash($data['password'], PASSWORD_BCRYPT);

            $stmt->bindParam(':name', $name);
            $stmt->bindParam(':email', $email);
            $stmt->bindParam(':password', $password);

            return $stmt->execute(); // Trả về true nếu thành công, false nếu thất bại
        } catch (PDOException $e) {
            error_log("Error in createUser: " . $e->getMessage());
            return false;
        }
    }

    // Cập nhật người dùng
    public function updateUser($id, $data)
    {
        // Cập nhật chỉ những trường được cung cấp
        $setParts = [];
        $params = [':id' => $id];

        if (isset($data['name'])) {
            $setParts[] = 'name = :name';
            $params[':name'] = htmlspecialchars(strip_tags($data['name']));
        }
        if (isset($data['email'])) {
            $setParts[] = 'email = :email';
            $params[':email'] = htmlspecialchars(strip_tags($data['email']));
        }
        if (isset($data['password']) && !empty($data['password'])) {
            $setParts[] = 'password = :password';
            $params[':password'] = password_hash($data['password'], PASSWORD_BCRYPT);
        }

        if (empty($setParts)) {
            return false; // Không có gì để cập nhật
        }

        $query = "UPDATE " . $this->table_name . " SET " . implode(', ', $setParts) . " WHERE id = :id";
        try {
            $stmt = $this->conn->prepare($query);
            return $stmt->execute($params);
        } catch (PDOException $e) {
            error_log("Error in updateUser: " . $e->getMessage());
            return false;
        }
    }

    // Xóa người dùng
    public function deleteUser($id)
    {
        $query = "DELETE FROM " . $this->table_name . " WHERE id = :id";
        try {
            $stmt = $this->conn->prepare($query);
            $stmt->bindParam(':id', $id, PDO::PARAM_INT);
            return $stmt->execute();
        } catch (PDOException $e) {
            error_log("Error in deleteUser: " . $e->getMessage());
            return false;
        }
    }
}
Giải thích:

Data Sanitation: Sử dụng htmlspecialchars và strip_tags để làm sạch dữ liệu đầu vào, phòng chống XSS.
Password Hashing: password_hash() là cách an toàn để lưu trữ mật khẩu, và PASSWORD_BCRYPT là thuật toán khuyến nghị.
Error Handling: Sử dụng try-catch để bắt và ghi log lỗi PDO, thay vì die(), giúp ứng dụng ổn định hơn trong môi trường production.
app/Modules/Users/UserController.php (Controller)
Controller này sẽ nhận request từ Router, gọi Model, và trả về JSON response.

PHP

<?php
// app/Modules/Users/UserController.php
namespace App\Modules\Users;

use App\Core\Controller; // Import lớp Controller cơ sở
use App\Modules\Users\User; // Import lớp User Model

class UserController extends Controller
{
    private $userModel; // Đối tượng Model cho User

    public function __construct()
    {
        parent::__construct(); // Gọi constructor của lớp cha
        $this->userModel = new User(); // Khởi tạo User Model
    }

    // GET /api/users
    public function index()
    {
        $users = $this->userModel->getAllUsers();
        $this->json($users); // Trả về danh sách người dùng dưới dạng JSON
    }

    // GET /api/users/{id}
    public function show($id)
    {
        $user = $this->userModel->getUserById($id);
        if ($user) {
            $this->json($user); // Trả về thông tin người dùng
        } else {
            $this->json(['message' => 'User not found'], 404); // Trả về lỗi 404 nếu không tìm thấy
        }
    }

    // POST /api/users
    public function store()
    {
        $data = $this->request->getBody(); // Lấy dữ liệu từ request body (JSON/form-data)

        // Kiểm tra dữ liệu đầu vào cơ bản
        if (empty($data['name']) || empty($data['email']) || empty($data['password'])) {
            $this->json(['message' => 'Name, email, and password are required'], 400); // Bad Request
        }

        // Kiểm tra email hợp lệ (có thể dùng filter_var)
        if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            $this->json(['message' => 'Invalid email format'], 400);
        }

        if ($this->userModel->createUser($data)) {
            $this->json(['message' => 'User created successfully', 'user_id' => $this->userModel->conn->lastInsertId()], 201); // 201 Created
        } else {
            // Có thể kiểm tra lỗi email trùng lặp cụ thể hơn nếu muốn
            $this->json(['message' => 'Failed to create user. Email might already exist.'], 500); // Internal Server Error
        }
    }

    // PUT /api/users/{id}
    public function update($id)
    {
        $data = $this->request->getBody(); // Lấy dữ liệu từ request body

        // Kiểm tra xem có dữ liệu để cập nhật không
        if (empty($data)) {
            $this->json(['message' => 'No data provided for update'], 400);
        }

        // Kiểm tra email hợp lệ nếu có trong data
        if (isset($data['email']) && !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            $this->json(['message' => 'Invalid email format'], 400);
        }

        if ($this->userModel->updateUser($id, $data)) {
            // Kiểm tra xem có hàng nào bị ảnh hưởng không
            if ($this->userModel->getUserById($id)) { // Kiểm tra user có tồn tại không
                $this->json(['message' => 'User updated successfully'], 200);
            } else {
                $this->json(['message' => 'User not found or no changes made'], 404); // Nếu ID không tồn tại
            }
        } else {
            $this->json(['message' => 'Failed to update user'], 500);
        }
    }

    // DELETE /api/users/{id}
    public function destroy($id)
    {
        // Kiểm tra người dùng có tồn tại trước khi xóa không
        if (!$this->userModel->getUserById($id)) {
            $this->json(['message' => 'User not found'], 404);
        }

        if ($this->userModel->deleteUser($id)) {
            $this->json(['message' => 'User deleted successfully'], 200); // 200 OK
        } else {
            $this->json(['message' => 'Failed to delete user'], 500);
        }
    }
}
Giải thích:

Dependency Injection (Implicit): User Model được khởi tạo trong constructor, có thể được coi là một dạng đơn giản của dependency injection.
Validation: Thêm logic kiểm tra dữ liệu đầu vào cơ bản (ví dụ: empty(), filter_var()) để đảm bảo dữ liệu hợp lệ trước khi gọi Model.
HTTP Status Codes: Sử dụng các mã status HTTP phù hợp (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error).
4.5. File public/.htaccess
File này sẽ định tuyến tất cả các request đến index.php trừ khi đó là một file hoặc thư mục tồn tại.

Apache

# public/.htaccess
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase /

    # Loại bỏ index.php khỏi URL
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^(.*)$ index.php/$1 [L]
</IfModule>
Lưu ý: Nếu bạn dùng Nginx, cấu hình sẽ khác. Với Apache, bạn cần đảm bảo mod_rewrite đã được bật.

4.6. File public/index.php (Điểm vào Backend)
Đây là file duy nhất mà tất cả các request PHP đi qua. Nó sẽ khởi tạo Router và định nghĩa các route API.

PHP

<?php
// public/index.php

// Đường dẫn tuyệt đối đến thư mục gốc của dự án
define('APP_ROOT', dirname(__DIR__));

// Nạp file khởi tạo ứng dụng
require_once APP_ROOT . '/app/init.php';

// Import các lớp cần thiết từ namespace App\Core
use App\Core\Router;
use App\Core\Request;
use App\Core\Response;

// Khởi tạo các đối tượng chính
$router = new Router();
$request = new Request();
$response = new Response();

// --- Định nghĩa các Routes API cho Module Users ---
// GET /api/users             -> Lấy tất cả người dùng
$router->get('/api/users', 'Users@index');
// GET /api/users/{id}        -> Lấy thông tin người dùng theo ID
$router->get('/api/users/{id}', 'Users@show');
// POST /api/users            -> Tạo người dùng mới
$router->post('/api/users', 'Users@store');
// PUT /api/users/{id}        -> Cập nhật người dùng theo ID
$router->put('/api/users/{id}', 'Users@update');
// DELETE /api/users/{id}     -> Xóa người dùng theo ID
$router->delete('/api/users/{id}', 'Users@destroy');

// --- Định nghĩa các Routes API cho Module Products (Ví dụ) ---
// Bạn sẽ tạo ProductController và Product Model tương tự Users
$router->get('/api/products', 'Products@index');
$router->get('/api/products/{id}', 'Products@show');
$router->post('/api/products', 'Products@store');
$router->put('/api/products/{id}', 'Products@update');
$router->delete('/api/products/{id}', 'Products@destroy');

// ... Thêm các route khác cho các module khác

// Điều phối request
$router->dispatch($request, $response);
Kiểm tra Backend:
Mở trình duyệt hoặc dùng Postman/Insomnia:

http://dashboard.local/api/users (GET) -> Nên trả về danh sách người dùng.
http://dashboard.local/api/users/1 (GET) -> Nên trả về thông tin user có ID là 1.
Thử các request POST, PUT, DELETE với dữ liệu JSON trong body.
5. Bắt Đầu Code Frontend (Vanilla JS SPA)
Frontend sẽ là một ứng dụng SPA, hoàn toàn chạy trên trình duyệt và giao tiếp với backend API.

5.1. File public/index.html
Đây là trang chính của SPA.

HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard - Vanilla JS SPA</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div id="app">
        <header>
            <h1>Admin Dashboard</h1>
            <nav>
                <a href="/" data-link>Dashboard</a>
                <a href="/users" data-link>Users</a>
                <a href="/products" data-link>Products</a>
            </nav>
        </header>
        <main id="content">
            </main>
    </div>

    <script type="module" src="/js/main.js"></script>
</body>
</html>
5.2. File CSS (public/css/style.css)
Một file CSS đơn giản để làm cho giao diện dễ nhìn hơn. Bạn có thể mở rộng sau.

CSS

/* public/css/style.css */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f4f4f4;
    color: #333;
}

#app {
    max-width: 1200px;
    margin: 20px auto;
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

header {
    background-color: #333;
    color: #fff;
    padding: 10px 20px;
    border-radius: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

header h1 {
    margin: 0;
    font-size: 1.5em;
}

nav a {
    color: #fff;
    text-decoration: none;
    margin-left: 15px;
    padding: 5px 10px;
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

nav a:hover {
    background-color: #555;
}

#content {
    padding: 20px 0;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

table th, table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}

table th {
    background-color: #eee;
}

button {
    background-color: #007bff;
    color: white;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    margin-right: 5px;
    transition: background-color 0.3s ease;
}

button:hover {
    background-color: #0056b3;
}

button.delete-user {
    background-color: #dc3545;
}
button.delete-user:hover {
    background-color: #c82333;
}

form {
    background-color: #f9f9f9;
    padding: 20px;
    border-radius: 8px;
    box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
    margin-top: 20px;
}

form div {
    margin-bottom: 15px;
}

form label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

form input[type="text"],
form input[type="email"],
form input[type="password"] {
    width: calc(100% - 20px);
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1em;
}

form button[type="submit"] {
    background-color: #28a745;
    padding: 10px 20px;
    font-size: 1em;
}

form button[type="submit"]:hover {
    background-color: #218838;
}

.message-success {
    color: green;
    background-color: #d4edda;
    border: 1px solid #c3e6cb;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
}

.message-error {
    color: red;
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
}
5.3. File public/js/router.js
Xử lý định tuyến phía frontend, thay đổi nội dung trang mà không tải lại.

JavaScript

// public/js/router.js
export class Router {
    constructor(routes) {
        this.routes = routes;

        // Lắng nghe sự kiện popstate (khi người dùng nhấn nút Back/Forward của trình duyệt)
        window.addEventListener('popstate', () => this.handleRouting());

        // Lắng nghe sự kiện DOMContentLoaded (khi HTML đã được tải đầy đủ)
        document.addEventListener('DOMContentLoaded', () => {
            // Lắng nghe sự kiện click trên toàn bộ body
            document.body.addEventListener('click', e => {
                // Kiểm tra nếu phần tử được click có thuộc tính data-link
                if (e.target.matches('[data-link]')) {
                    e.preventDefault(); // Ngăn chặn hành vi mặc định của thẻ <a>
                    this.navigateTo(e.target.href); // Chuyển hướng nội bộ SPA
                }
            });
            this.handleRouting(); // Xử lý định tuyến ban đầu khi tải trang
        });
    }

    // Chuyển hướng đến một URL mới trong SPA
    navigateTo(url) {
        // Sử dụng History API để thay đổi URL mà không tải lại trang
        history.pushState(null, null, url);
        this.handleRouting(); // Kích hoạt lại việc xử lý định tuyến
    }

    // Xử lý logic định tuyến dựa trên URL hiện tại
    async handleRouting() {
        const path = window.location.pathname; // Lấy đường dẫn hiện tại (ví dụ: /, /users, /users/edit/1)
        const contentDiv = document.getElementById('content'); // Lấy div để render nội dung

        // Tìm route khớp với đường dẫn hiện tại
        let matchedRoute = null;
        let params = [];

        for (const route of this.routes) {
            // Biến đổi route path (ví dụ: /users/{id}) thành regex
            // Dùng \/ để khớp với dấu gạch chéo
            // Dùng ([a-zA-Z0-9_]+) để bắt các tham số
            const routePathRegex = new RegExp(`^${route.path.replace(/\{([a-zA-Z0-9_]+)\}/g, '([a-zA-Z0-9_]+)')}$`);
            const match = path.match(routePathRegex);

            if (match) {
                matchedRoute = route;
                params = match.slice(1); // Lấy các tham số (bỏ qua phần tử đầu tiên là full match)
                break; // Tìm thấy route khớp, thoát vòng lặp
            }
        }

        if (matchedRoute) {
            try {
                const view = new matchedRoute.view(); // Tạo instance của Page/View
                // Gọi getHtml để lấy nội dung HTML và truyền các tham số
                contentDiv.innerHTML = await view.getHtml(params);
                // Gắn các sự kiện sau khi HTML đã được render vào DOM
                view.attachEvents();
            } catch (error) {
                console.error('Error rendering page:', error);
                contentDiv.innerHTML = `<h1>Error</h1><p>Failed to load page: ${error.message}</p>`;
            }
        } else {
            // Nếu không có route nào khớp, hiển thị trang 404
            contentDiv.innerHTML = `<h1>404 Not Found</h1><p>The page you requested could not be found.</p>`;
        }
    }
}
Giải thích:

History API: history.pushState() cho phép thay đổi URL trình duyệt mà không cần reload trang.
data-link: Một thuộc tính tùy chỉnh để đánh dấu các liên kết mà router cần xử lý nội bộ.
Dynamic Routing: Sử dụng regex để bắt các tham số trong URL (ví dụ: {id} trong /users/edit/{id}).
5.4. File public/js/api.js
Tập trung các hàm gọi API backend tại đây.

JavaScript

// public/js/api.js

// URL cơ sở cho API của bạn
// Đảm bảo rằng PHP backend của bạn có thể truy cập được tại đây
const API_BASE_URL = 'http://dashboard.local/api'; // Thay đổi nếu tên miền của bạn khác

// Hàm chung để gửi các request HTTP
async function request(url, method = 'GET', data = null) {
    const options = {
        method,
        headers: {
            'Content-Type': 'application/json', // Gửi dữ liệu dưới dạng JSON
            'Accept': 'application/json',       // Chấp nhận phản hồi JSON
            // 'Authorization': `Bearer ${localStorage.getItem('jwt')}` // Thêm token nếu có authentication
        },
    };

    if (data) {
        // Nếu có dữ liệu, chuyển nó thành chuỗi JSON và thêm vào body
        options.body = JSON.stringify(data);
    }

    try {
        const response = await fetch(`${API_BASE_URL}${url}`, options);

        if (!response.ok) {
            // Nếu response không thành công (status code 4xx hoặc 5xx)
            const errorData = await response.json(); // Cố gắng đọc thông báo lỗi từ JSON
            throw new Error(errorData.message || 'Something went wrong');
        }

        // Kiểm tra nếu response có nội dung (ví dụ: DELETE có thể không trả về gì)
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return await response.json(); // Trả về JSON parsed
        }
        return null; // Không có nội dung JSON
    } catch (error) {
        console.error('API Error:', error);
        throw error; // Ném lại lỗi để component gọi có thể xử lý
    }
}

// Đối tượng chứa các hàm API liên quan đến User
export const UsersAPI = {
    getAll: () => request('/users'),
    getById: (id) => request(`/users/${id}`),
    create: (data) => request('/users', 'POST', data),
    update: (id, data) => request(`/users/${id}`, 'PUT', data),
    delete: (id) => request(`/users/${id}`, 'DELETE'),
};

// Đối tượng chứa các hàm API liên quan đến Product
export const ProductsAPI = {
    getAll: () => request('/products'),
    getById: (id) => request(`/products/${id}`),
    create: (data) => request('/products', 'POST', data),
    update: (id, data) => request(`/products/${id}`, 'PUT', data),
    delete: (id) => request(`/products/${id}`, 'DELETE'),
};

// ... Thêm các API khác nếu cần
Lưu ý: Thay đổi http://dashboard.local/api thành URL API của bạn.

5.5. Các Component và Pages
public/js/components/UserList.js
Component này sẽ hiển thị danh sách người dùng và xử lý các hành động như chỉnh sửa, xóa.

JavaScript

// public/js/components/UserList.js
import { UsersAPI } from '../api.js';

export class UserList {
    constructor() {
        this.users = []; // Lưu trữ danh sách người dùng
    }

    // Lấy dữ liệu người dùng từ API
    async fetchUsers() {
        try {
            this.users = await UsersAPI.getAll();
        } catch (error) {
            console.error('Error fetching users:', error);
            this.users = []; // Đảm bảo mảng rỗng nếu có lỗi
            // Hiển thị thông báo lỗi cho người dùng (có thể thêm div thông báo)
            alert('Failed to load users: ' + error.message);
        }
    }

    // Tạo HTML cho danh sách người dùng
    async getHtml() {
        await this.fetchUsers(); // Đảm bảo dữ liệu đã được tải

        if (this.users.length === 0) {
            return `<p class="message-info">No users found. <button id="add-new-user-empty">Add New User</button></p>`;
        }

        return `
            <h2>Users List</h2>
            <table>
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Name</th>
                        <th>Email</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    ${this.users.map(user => `
                        <tr>
                            <td>${user.id}</td>
                            <td>${user.name}</td>
                            <td>${user.email}</td>
                            <td>
                                <button class="edit-user" data-id="${user.id}">Edit</button>
                                <button class="delete-user" data-id="${user.id}">Delete</button>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
            <button id="add-new-user">Add New User</button>
        `;
    }

    // Gắn các sự kiện cho các nút sau khi HTML được render
    attachEvents() {
        // Lắng nghe sự kiện click cho các nút Edit
        document.querySelectorAll('.edit-user').forEach(button => {
            button.addEventListener('click', (e) => {
                const userId = e.target.dataset.id;
                // Sử dụng router của SPA để chuyển hướng
                history.pushState(null, null, `/users/edit/${userId}`);
                window.dispatchEvent(new Event('popstate')); // Kích hoạt router để xử lý route mới
            });
        });

        // Lắng nghe sự kiện click cho các nút Delete
        document.querySelectorAll('.delete-user').forEach(button => {
            button.addEventListener('click', async (e) => {
                const userId = e.target.dataset.id;
                if (confirm(`Are you sure you want to delete user with ID ${userId}?`)) {
                    try {
                        await UsersAPI.delete(userId);
                        alert('User deleted successfully!');
                        // Refresh danh sách bằng cách kích hoạt lại router về trang users
                        history.pushState(null, null, '/users');
                        window.dispatchEvent(new Event('popstate'));
                    } catch (error) {
                        alert('Failed to delete user: ' + error.message);
                        console.error('Delete User Error:', error);
                    }
                }
            });
        });

        // Lắng nghe sự kiện click cho nút "Add New User"
        const addNewButton = document.getElementById('add-new-user') || document.getElementById('add-new-user-empty');
        if (addNewButton) {
            addNewButton.addEventListener('click', () => {
                history.pushState(null, null, '/users/new');
                window.dispatchEvent(new Event('popstate'));
            });
        }
    }
}
public/js/components/UserForm.js
Component này sẽ tạo form cho việc thêm mới hoặc chỉnh sửa người dùng.

JavaScript

// public/js/components/UserForm.js
import { UsersAPI } from '../api.js';

export class UserForm {
    constructor() {
        this.mode = 'new'; // 'new' hoặc 'edit'
        this.userId = null;
        this.user = {}; // Dữ liệu người dùng khi ở chế độ edit
    }

    // Lấy HTML cho form
    async getHtml(mode = 'new', userId = null) {
        this.mode = mode;
        this.userId = userId;
        this.user = { name: '', email: '', password: '' }; // Reset form

        let formTitle = 'Add New User';
        let submitButtonText = 'Create User';

        if (this.mode === 'edit' && this.userId) {
            formTitle = `Edit User (ID: ${this.userId})`;
            submitButtonText = 'Update User';
            try {
                this.user = await UsersAPI.getById(this.userId);
                if (!this.user) {
                    return `<p class="message-error">User not found!</p>`;
                }
            } catch (error) {
                console.error('Error fetching user for edit:', error);
                return `<p class="message-error">Failed to load user data: ${error.message}</p>`;
            }
        }

        return `
            <h2>${formTitle}</h2>
            <form id="user-form">
                <div>
                    <label for="name">Name:</label>
                    <input type="text" id="name" name="name" value="${this.user.name || ''}" required>
                </div>
                <div>
                    <label for="email">Email:</label>
                    <input type="email" id="email" name="email" value="${this.user.email || ''}" required>
                </div>
                <div>
                    <label for="password">Password:</label>
                    <input type="password" id="password" name="password" ${this.mode === 'new' ? 'required' : ''}>
                    ${this.mode === 'edit' ? '<small>Leave blank to keep current password</small>' : ''}
                </div>
                <button type="submit">${submitButtonText}</button>
                <button type="button" id="cancel-user-form">Cancel</button>
            </form>
        `;
    }

    // Gắn các sự kiện cho form
    attachEvents() {
        const form = document.getElementById('user-form');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();

                const formData = new FormData(form);
                const data = {};
                for (const [key, value] of formData.entries()) {
                    // Không gửi password nếu nó trống rỗng trong chế độ edit
                    if (this.mode === 'edit' && key === 'password' && value === '') {
                        continue;
                    }
                    data[key] = value;
                }

                try {
                    let response;
                    if (this.mode === 'new') {
                        response = await UsersAPI.create(data);
                        alert(response.message || 'User created successfully!');
                    } else { // 'edit'
                        response = await UsersAPI.update(this.userId, data);
                        alert(response.message || 'User updated successfully!');
                    }
                    // Chuyển hướng về trang danh sách người dùng sau khi thành công
                    history.pushState(null, null, '/users');
                    window.dispatchEvent(new Event('popstate'));
                } catch (error) {
                    alert('Operation failed: ' + error.message);
                    console.error('Form Submit Error:', error);
                }
            });
        }

        const cancelButton = document.getElementById('cancel-user-form');
        if (cancelButton) {
            cancelButton.addEventListener('click', () => {
                history.pushState(null, null, '/users');
                window.dispatchEvent(new Event('popstate'));
            });
        }
    }
}
public/js/pages/UsersPage.js
Trang quản lý người dùng, sẽ quyết định hiển thị danh sách hay form tùy thuộc vào URL.

JavaScript

// public/js/pages/UsersPage.js
import { UserList } from '../components/UserList.js';
import { UserForm } from '../components/UserForm.js';

export class UsersPage {
    constructor() {
        this.userList = new UserList();
        this.userForm = new UserForm();
    }

    async getHtml(params = []) {
        // params sẽ chứa các giá trị từ route động (ví dụ: 'new', 'edit', '1')
        const action = params[0]; // Có thể là 'new' hoặc 'edit'
        const userId = params[1]; // ID người dùng nếu là 'edit'

        let contentHtml = '';
        if (action === 'new') {
            contentHtml = await this.userForm.getHtml('new');
        } else if (action === 'edit' && userId) {
            contentHtml = await this.userForm.getHtml('edit', userId);
        } else {
            // Mặc định hiển thị danh sách người dùng
            contentHtml = await this.userList.getHtml();
        }
        return `
            <div class="users-page">
                ${contentHtml}
            </div>
        `;
    }

    // Gắn sự kiện tùy thuộc vào nội dung đang hiển thị
    attachEvents() {
        const path = window.location.pathname;
        if (path.includes('/users/new') || path.includes('/users/edit')) {
            this.userForm.attachEvents();
        } else {
            this.userList.attachEvents();
        }
    }
}
public/js/pages/DashboardPage.js
Một trang ví dụ đơn giản.

JavaScript

// public/js/pages/DashboardPage.js
export class DashboardPage {
    async getHtml() {
        return `
            <div class="dashboard-page">
                <h2>Welcome to the Admin Dashboard!</h2>
                <p>This is your main dashboard area. You can add widgets and summary information here.</p>
                <ul>
                    <li>Total Users: <strong>100+</strong></li>
                    <li>Total Products: <strong>500+</strong></li>
                    <li>Recent Orders: <strong>15</strong></li>
                </ul>
                <p>Use the navigation above to manage users and products.</p>
            </div>
        `;
    }

    attachEvents() {
        // Không có sự kiện đặc biệt nào cho trang này
    }
}
public/js/pages/ProductsPage.js
Bạn sẽ phát triển trang này tương tự như UsersPage sau khi tạo ProductController, Product Model và các component frontend cho Products.

JavaScript

// public/js/pages/ProductsPage.js
// Import ProductList và ProductForm tương tự như UsersPage
// import { ProductList } from '../components/ProductList.js';
// import { ProductForm } from '../components/ProductForm.js';

export class ProductsPage {
    constructor() {
        // this.productList = new ProductList();
        // this.productForm = new ProductForm();
    }

    async getHtml(params = []) {
        // Logic tương tự UsersPage để hiển thị danh sách hoặc form sản phẩm
        return `
            <div class="products-page">
                <h2>Manage Products</h2>
                <p>This section is under construction. You will manage your products here.</p>
                <button id="add-new-product">Add New Product</button>
            </div>
        `;
    }

    attachEvents() {
        // Logic gắn sự kiện cho các nút/form sản phẩm
        const addNewButton = document.getElementById('add-new-product');
        if (addNewButton) {
            addNewButton.addEventListener('click', () => {
                alert('Add Product functionality coming soon!');
                // history.pushState(null, null, '/products/new');
                // window.dispatchEvent(new Event('popstate'));
            });
        }
    }
}
5.6. File public/js/main.js (Điểm vào Frontend)
File này sẽ khởi tạo Router và định nghĩa các route cho SPA.

JavaScript

// public/js/main.js
import { Router } from './router.js'; // Import Router
import { DashboardPage } from './pages/DashboardPage.js'; // Import các trang
import { UsersPage } from './pages/UsersPage.js';
import { ProductsPage } from './pages/ProductsPage.js';

// Định nghĩa các route cho SPA
const routes = [
    { path: '/', view: DashboardPage }, // Trang Dashboard
    { path: '/users', view: UsersPage }, // Trang danh sách người dùng
    { path: '/users/new', view: UsersPage }, // Trang thêm người dùng mới
    { path: '/users/edit/{id}', view: UsersPage }, // Trang chỉnh sửa người dùng với tham số ID
    { path: '/products', view: ProductsPage }, // Trang quản lý sản phẩm
    // { path: '/products/new', view: ProductsPage },
    // { path: '/products/edit/{id}', view: ProductsPage },
    // ... Thêm các route khác nếu cần
];

// Khởi tạo Router với các route đã định nghĩa
const router = new Router(routes);
Kiểm tra Frontend:
Mở trình duyệt và truy cập http://dashboard.local. Bạn sẽ thấy giao diện dashboard và có thể điều hướng qua các liên kết Dashboard, Users, Products mà không cần tải lại trang.
Thử các chức năng Thêm, Sửa, Xóa người dùng trên trang /users.

6. Tổng Kết và Các Bước Tiếp Theo
Bạn đã có một ứng dụng Admin Dashboard cơ bản hoạt động với PHP MVC thuần ở backend (dưới dạng API) và Vanilla JS SPA ở frontend.

Các bước nâng cao bạn có thể thực hiện:

Hoàn thiện Module Products: Tương tự như Users, hãy tạo ProductController, Product Model ở backend và ProductList.js, ProductForm.js ở frontend.
Authentication và Authorization:
Thêm chức năng đăng nhập/đăng xuất và bảo vệ các API bằng JWT (JSON Web Tokens).
Ở frontend, triển khai việc lưu trữ token và gửi kèm trong header của mỗi request.
Tạo trang Login cho SPA.
Validation nâng cao: Sử dụng các thư viện validation phía PHP để xử lý lỗi input chi tiết hơn.
Phân trang, Tìm kiếm, Lọc: Triển khai các tính năng này ở cả backend (truy vấn DB) và frontend (cập nhật UI).
Xử lý lỗi UI tốt hơn: Thay vì alert(), hãy hiển thị thông báo lỗi/thành công đẹp hơn (ví dụ: dùng div thông báo).
Loading States: Hiển thị trạng thái "Loading..." khi dữ liệu đang được tải từ API.
Responsive Design: Sử dụng CSS để làm cho dashboard hiển thị tốt trên các kích thước màn hình khác nhau.
Form Validation Frontend: Thêm validation bằng JavaScript trực tiếp trên form để cung cấp phản hồi tức thì cho người dùng.
Đây là một dự án lớn nhưng rất giá trị để học hỏi. Hãy đi từng bước nhỏ, kiểm tra từng phần sau khi code để đảm bảo mọi thứ hoạt động đúng như mong đợi.

Nếu bạn gặp khó khăn ở bất kỳ bước nào hoặc muốn đi sâu hơn vào một phần cụ thể, đừng ngần ngại hỏi nhé!