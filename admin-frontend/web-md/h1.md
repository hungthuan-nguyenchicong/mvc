## trình lắng nghe sự kiện

Bạn đã đạt đến một yêu cầu chung trong định tuyến phía máy khách! Bạn muốn Sidebarphản ứng với các thay đổi đường dẫn mà không cần Router"nói" rõ ràng mỗi khi nhấp vào liên kết. Đây là một kịch bản hoàn hảo để sử dụng mẫu Event Emitter .

Sau đây là cách chúng tôi sẽ triển khai:

Tạo một trung tâm EventEmitter: Đây sẽ là một tiện ích đơn giản cho phép các phần khác nhau trong ứng dụng của bạn "phát hành" (phát ra) các sự kiện và "theo dõi" (lắng nghe) chúng.
Tạo Routersự kiện phát ra: Bất cứ khi nào Routerphát hiện đường dẫn thay đổi (thông qua nhấp vào liên kết hoặc trình duyệt quay lại/tiến lên), nó sẽ phát ra sự kiện với đường dẫn mới.
Thực hiện Sidebarlắng nghe sự kiện: Sẽ Sidebarđăng ký sự kiện thay đổi đường dẫn của bộ định tuyến. Khi nghe sự kiện này, nó sẽ cập nhật trạng thái liên kết đang hoạt động.
Cách tiếp cận này tách rời Routervà Sidebar, giúp ứng dụng của bạn có tính mô-đun hơn và dễ bảo trì hơn.

Bước 1: Tạo EventEmittertiện ích
Đầu tiên, hãy tạo một tệp tiện ích nhỏ cho trình phát sự kiện của chúng ta.
src/utils/EventEmitter.js
0:32 25 thg 6

Mở

Bước 2: Cập nhật Router.jsđể phát ra sự kiện
Bây giờ, sẽ có một sự kiện Routerđược nhập vào appEventsbất cứ khi nào có bản cập nhật.emit'pathChanged'currentPath
src/core/Router.js (Đã cập nhật để Phát ra Sự kiện)
0:32 25 thg 6

Mở

Bước 3: Cập nhật Sidebar.jsđể lắng nghe sự kiện
Bây Sidebargiờ sẽ nhận được currentPaththông qua trình phát sự kiện, nghĩa là clickLinkkhông cần phải truyền đường dẫn trực tiếp trong các lần điều hướng tiếp theo nữa.
src/components/Sidebar.js (Đã cập nhật để lắng nghe sự kiện)
0:32 25 thg 6

Mở

Bước 4: Cập nhật main.js(Điều chỉnh nhỏ)
Tệp main.jstin vẫn giữ nguyên phần lớn, nhưng lệnh gọi đến sidebarInstance.clickLinknow cho biết rõ ràng rằng nó đang truyền đường dẫn ban đầu để thiết lập.
src/main.js (Đã hoàn thiện)
0:32 25 thg 6

Mở

Tóm tắt những thay đổi và cách thức hoạt động:
src/utils/EventEmitter.js: Một tệp mới định nghĩa một tệp đơn giản EventEmittercho phép bạn phát ra các sự kiện tùy chỉnh và đăng ký chúng từ bất kỳ đâu trong ứng dụng của bạn.
src/core/Router.js:
Nhập khẩu appEvents.
Bất cứ khi nào this.#currentPathname(path)được gọi (xảy ra khi nhấp vào liên kết và popstate), thì bây giờ nó cũng gọi appEvents.emit('pathChanged', this.currentPath).
Nó cũng phát ra tia lửa pathChangedkhi tải lần đầu.
src/components/Sidebar.js:
Nhập khẩu appEvents.
Phương _updateActiveClass(path)thức trợ giúp được giới thiệu để quản lý việc thêm/xóa lớp 'hoạt động' trên các liên kết.
Trong clickLink(initialPath), bây giờ:
Gọi this._updateActiveClass(initialPath)để thiết lập trạng thái hoạt động chính xác khi tải ban đầu.
Đăng ký vàoappEvents.on('pathChanged', (newPath) => { ... }); . Điều này có nghĩa là bất cứ khi nào Bộ định tuyến phát ra 'pathChanged', Sidebar _updateActiveClasssẽ được gọi với đường dẫn mới, giúp duy trì sự đồng bộ.
src/main.js: Cuộc gọi sidebarInstance.clickLink(routerInstance.currentPath)hiện rõ ràng hơn, cho biết nó đang vượt qua đường dẫn ban đầu để thiết lập thanh bên.
Thiết lập này đạt được sự tách rời mong muốn: Routerchỉ cần thông báo rằng đường dẫn của nó đã thay đổi, sau đó Sidebarlắng nghe và phản ứng mà không cần gọi phương thức trực tiếp nào giữa chúng ngoài thiết lập ban đầu.

## src/utils/EventEmitter.js

// src/utils/EventEmitter.js

/**
 * A simple event emitter class to facilitate communication between decoupled components.
 * Components can subscribe to events using 'on' and publish events using 'emit'.
 */
class EventEmitter {
    constructor() {
        this.events = {}; // Stores event names and their registered listeners
    }

    /**
     * Registers a listener function for a specific event name.
     * @param {string} eventName - The name of the event to listen for.
     * @param {Function} listener - The callback function to execute when the event is emitted.
     */
    on(eventName, listener) {
        if (!this.events[eventName]) {
            this.events[eventName] = []; // Initialize array for new event names
        }
        this.events[eventName].push(listener); // Add the listener to the event's list
    }

    /**
     * Emits an event, calling all registered listeners for that event name.
     * @param {string} eventName - The name of the event to emit.
     * @param {any} data - The data to pass to the listeners (optional).
     */
    emit(eventName, data) {
        if (this.events[eventName]) {
            // Create a shallow copy of the listeners array to prevent issues
            // if listeners are removed during iteration (e.g., 'once' functionality).
            [...this.events[eventName]].forEach(listener => listener(data));
        }
    }
}

// Export a single, globally accessible instance of the EventEmitter
export const appEvents = new EventEmitter();

## src/core/Router.js

// src/core/Router.js
import { appEvents } from '../utils/EventEmitter.js'; // Import the event emitter

/**
 * Renders content into the 'content' div based on the given path.
 * @param {string} path - The path to render content for.
 */
function renderContent(path) {
    const contentDiv = document.getElementById('content');
    if (!contentDiv) {
        console.error("Router.js: No element with id 'content' found to render content.");
        return;
    }
    // Use a switch statement to render different content based on the path
    switch (path) {
        case '/':
            contentDiv.innerHTML = '<h1>Welcome to the Dashboard!</h1><p>This is your main dashboard view.</p>';
            break;
        case '/posts':
            contentDiv.innerHTML = '<h1>All Posts</h1><p>Here you can view and manage all your blog posts.</p>';
            break;
        case '/post/create':
            contentDiv.innerHTML = '<h1>Create New Post</h1><p>Use this form to write and publish a new post.</p>';
            break;
        case '/category/post':
            contentDiv.innerHTML = '<h1>Post Categories</h1><p>Organize your posts into categories.</p>';
            break;
        case '/product':
            contentDiv.innerHTML = '<h1>All Products</h1><p>Browse and manage your product catalog.</p>';
            break;
        case '/product/create':
            contentDiv.innerHTML = '<h1>Create New Product</h1><p>Add a new product to your inventory.</p>';
            break;
        case '/category/product':
            contentDiv.innerHTML = '<h1>Product Categories</h1><p>Define categories for your products.</p>';
            break;
        case '/settings':
            contentDiv.innerHTML = '<h1>Settings</h1><p>Adjust application settings and preferences.</p>';
            break;
        case '/logout':
            contentDiv.innerHTML = '<h1>Logging Out...</h1><p>You have been successfully logged out.</p>';
            break;
        default:
            contentDiv.innerHTML = '<h1>404 - Page Not Found</h1><p>The page you are looking for does not exist.</p>';
            break;
    }
}

/**
 * A utility function for logging messages to the console.
 * @param {any} t - The message or data to log.
 */
function tt(t) {
    console.log(t);
}

/**
 * The Router class handles client-side routing, managing URL changes
 * and rendering content accordingly without full page reloads.
 */
export class Router {
    /**
     * Initializes the Router with an empty routes array and sets
     * the initial current path from the browser's location.
     */
    constructor() {
        this.routes = [];
        this.currentPath = window.location.pathname;
        tt(`Router initialized with current path: ${this.currentPath}`); // Log initial path
    }

    /**
     * Private method to update the current path property.
     * This method is internal to the Router class.
     * It also emits a 'pathChanged' event.
     * @param {string} path - The new path to set.
     * @returns {string} The updated current path.
     */
    #currentPathname(path) {
        this.currentPath = path;
        // Emit an event whenever the path changes internally
        appEvents.emit('pathChanged', this.currentPath);
        return this.currentPath;
    }

    /**
     * Initializes the router by setting up event listeners for
     * browser history changes (popstate) and link clicks.
     */
    init() {
        // Listen for 'popstate' event (when user clicks back/forward in browser)
        window.addEventListener('popstate', () => {
            this.currentPath = window.location.pathname;
            tt(`Path changed via popstate to: ${this.currentPath}`);
            renderContent(this.currentPath); // Re-render content for the new history state
            appEvents.emit('pathChanged', this.currentPath); // Emit event on popstate
        });

        // Listen for clicks on the entire document body
        document.body.addEventListener('click', (e) => {
            // Find the closest anchor tag with a 'data-link' attribute
            const routeLink = e.target.closest('a[data-link]');
            if (routeLink) {
                e.preventDefault(); // Prevent default browser navigation
                const path = routeLink.getAttribute('href'); // Get the href value

                // Update the internal current path using the private helper method, which also emits an event
                this.#currentPathname(path);

                // Push the new state to the browser history, changing the URL
                history.pushState(null, '', path);
                
                // Render content for the new path
                renderContent(path);
                tt(`Navigated to: ${path}`); // Log the navigation
            }
        });

        // Initial content render when the page first loads
        renderContent(this.currentPath);
        tt(`Initial content rendered for path: ${this.currentPath}`); // Confirm initial render
        appEvents.emit('pathChanged', this.currentPath); // Emit initial path
    }
}

## src/components/Sidebar.js

// src/components/Sidebar.js
import './sidebar.scss';
import { appEvents } from '../utils/EventEmitter.js'; // Import the event emitter

function tt(t) {
    console.log(t);
}

export class Sidebar {
    constructor() {
        this.sidebarElement = null;
        this.linkItems = null;
    }

    render() {
        this.sidebarElement = document.createElement('aside');
        this.sidebarElement.innerHTML = /* html */ `
            <nav class="sidebar">
                <ul>
                    <li><a href="/" class="nav-link" data-link>Dashboard</a></li>
                    <hr>
                    <li>
                        <a href="/posts" class="nav-link" data-link>Tất cả Bài viết</a>
                        <ul>
                            <li><a href="/post/create" data-link>Thêm Mới</a></li>
                            <li><a href="/category/post" data-link>Danh mục bài viết</a></li>
                        </ul>
                    </li>
                    <hr>
                    <li>
                        <a href="/product" class="nav-link" data-link>Tất cả Sản Phẩm</a>
                        <ul>
                            <li><a href="/product/create" data-link>Thêm Mới</a></li>
                            <li><a href="/category/product" data-link>Danh mục Sản phẩm</a></li>
                        </ul>
                    </li>
                    <hr>
                    <li><a href="/settings" class="nav-link" data-link>Cài đặt</a></li>
                    <hr>
                    <li><a href="/logout" class="nav-link" data-link>Logout</a></li>
                </ul>
            </nav>
        `;
        return this.sidebarElement;
    }

    /**
     * Updates the 'active' class on sidebar links based on the provided path.
     * @param {string} path - The path to mark as active.
     */
    _updateActiveClass(path) {
        if (!this.linkItems) {
            // Ensure linkItems are queried only once after render
            this.linkItems = this.sidebarElement.querySelectorAll('a[data-link]');
        }

        this.linkItems.forEach(link => {
            link.classList.remove('active'); // Remove active from all links first
            if (link.getAttribute('href') === path) {
                link.classList.add('active'); // Add active to the matching link
            }
        });
        tt(`Sidebar: Active link updated to: ${path}`);
    }

    /**
     * Initializes the sidebar's click listeners and subscribes to path changes.
     * It receives the initial path to set the active link on load.
     * @param {string} initialPath - The current path when the application loads.
     */
    clickLink(initialPath) {
        if (!this.sidebarElement) {
            console.warn('Sidebar: sidebarElement not rendered yet.');
            return;
        }

        // Set the initial active link based on the path provided during initialization
        this._updateActiveClass(initialPath);

        // Attach click listeners to all sidebar links to manage active class locally
        // (Router's click listener will handle history.pushState and renderContent)
        this.linkItems.forEach(link => {
            link.addEventListener('click', (e) => {
                // The Router will handle the actual navigation and then emit 'pathChanged'
                // This local click listener can simply log or do other UI things if needed,
                // but the active state will be handled by the 'pathChanged' event.
                // For a purely event-driven active state, you could remove this local logic.
                // However, keeping it here immediately updates UI for clicks for snappier feel
                // before the Router's event propagates.
                
                // If you want to ONLY rely on the event emitter for active state,
                // remove the local active class toggling here.
                // For now, we'll let the event handler be the single source of truth
                // and simply ensure this click doesn't interfere.
                // The _updateActiveClass will be called by the appEvents listener.
            });
        });

        // Subscribe to path changes emitted by the Router
        appEvents.on('pathChanged', (newPath) => {
            this._updateActiveClass(newPath); // Update active class when path changes
        });
    }
}

## src/main.js

// src/main.js
import './main.scss';
import { Header } from './components/Header.js'
import { Sidebar } from "./components/Sidebar.js";
import { Router } from './core/Router.js';

document.addEventListener('DOMContentLoaded', () => {
    const app = document.getElementById('app');
    if (!app) {
        console.warn('No element with id="app" found. Cannot initialize application.');
        return;
    }

    // Initialize and append Header
    const headerInstance = new Header();
    const headerElement = headerInstance.render();
    app.appendChild(headerElement);

    // Initialize and append Sidebar
    const sidebarInstance = new Sidebar();
    const sidebarElement = sidebarInstance.render();
    app.appendChild(sidebarElement);

    // Create and append content div (where router renders content)
    const contentElement = document.createElement('div');
    contentElement.id = 'content';
    app.appendChild(contentElement);

    // Initialize the Router
    const routerInstance = new Router();
    routerInstance.init();

    // Initialize the Sidebar's click handlers and set its initial active state
    // The Sidebar will now listen for path changes via appEvents
    sidebarInstance.clickLink(routerInstance.currentPath);
});
