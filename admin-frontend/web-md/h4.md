# h4

Bạn muốn Router có khả năng tự động lắng nghe các sự kiện click trên tất cả các liên kết có data-link trong toàn bộ ứng dụng, thay vì chỉ dựa vào Sidebar để dispatch sự kiện. Điều này sẽ làm cho Router mạnh mẽ hơn và độc lập hơn.

Để làm được điều này, Router cần thực hiện những bước sau:

Lắng nghe sự kiện click trên document: Sử dụng event delegation. Thay vì gắn event listener cho từng liên kết a[data-link] (mà có thể rất nhiều và được tạo động), chúng ta sẽ gắn một listener duy nhất vào document (hoặc một container cha lớn hơn như #app).
Kiểm tra e.target: Khi một sự kiện click xảy ra, kiểm tra xem phần tử được click (e.target) hoặc một trong các phần tử cha của nó có phải là một liên kết a[data-link] hay không.
Ngăn chặn mặc định và cập nhật URL: Nếu là a[data-link], ngăn chặn hành vi mặc định của trình duyệt và sử dụng history.pushState để thay đổi URL.
Kích hoạt Router: Sau khi thay đổi URL, Router sẽ tự gọi lại phương thức route() của chính nó.
Cập nhật Code: Router tự lắng nghe a[data-link]
1. Cập nhật src/core/Router.js (Quan trọng nhất)
JavaScript

// src/core/Router.js

export class Router {
    constructor(targetElementId, routes) {
        this.targetElement = document.getElementById(targetElementId);
        this.routes = routes.map(route => {
            const pathRegex = new RegExp(`^${route.path.replace(/:([a-zA-Z0-9_]+)/g, '(?<$1>[a-zA-Z0-9_]+)')}$`);
            return { ...route, pathRegex };
        });
        this.init();
    }

    init() {
        // Lắng nghe sự kiện 'popstate' (khi người dùng dùng nút back/forward của trình duyệt)
        window.addEventListener('popstate', () => this.route(window.location.pathname));

        // --- Cải tiến: Router tự lắng nghe các click trên link data-link ---
        document.body.addEventListener('click', e => { // Gắn listener vào body hoặc #app
            // Kiểm tra xem phần tử click có phải là a[data-link] không, hoặc là con của nó
            const targetLink = e.target.closest('a[data-link]');

            if (targetLink) {
                e.preventDefault(); // Ngăn chặn hành vi mặc định của thẻ a

                const newPath = targetLink.getAttribute('href');

                // Nếu URL hiện tại khác với URL mới, thì mới pushState
                // Điều này tránh push trùng lặp vào history khi click vào link của trang hiện tại
                if (window.location.pathname !== newPath) {
                    history.pushState(null, null, newPath);
                    this.route(newPath); // Gọi route để cập nhật nội dung
                } else {
                    // Nếu click vào link của trang hiện tại, vẫn có thể muốn update UI (ví dụ: active class)
                    // Ở đây, Router chỉ lo về nội dung, việc active class sẽ do Sidebar (hoặc component menu) tự xử lý
                    // Tuy nhiên, việc Sidebar/Menu lắng nghe routeChange là cách tốt nhất.
                }
            }
        });
        // ------------------------------------------------------------------

        // Kích hoạt định tuyến lần đầu khi Router được khởi tạo
        this.route(window.location.pathname);
    }

    async route(path) {
        console.log(`Routing to: ${path}`);

        let match = null;
        let params = {};
        let foundRoute = null;

        for (const route of this.routes) {
            const regexMatch = path.match(route.pathRegex);
            if (regexMatch) {
                foundRoute = route;
                params = regexMatch.groups || {};
                break;
            }
        }

        if (!foundRoute) {
            foundRoute = {
                path: '/404',
                view: () => `
                    <h1>404 - Không tìm thấy trang</h1>
                    <p>Trang bạn đang tìm không tồn tại.</p>
                `
            };
            params = {};
        }

        const content = await foundRoute.view(params);

        if (this.targetElement) {
            this.targetElement.innerHTML = content;
        } else {
            console.error(`Target element with ID '${this.targetElement.id}' not found.`);
        }

        // --- Quan trọng: Kích hoạt một CustomEvent để CÁC COMPONENT KHÁC lắng nghe ---
        // Ví dụ: Sidebar sẽ lắng nghe event này để cập nhật trạng thái active
        window.dispatchEvent(new CustomEvent('routeChange', { detail: path }));
        // -------------------------------------------------------------------------
    }
}
2. Cập nhật src/components/Sidebar.js (Loại bỏ listener cũ và lắng nghe routeChange)
Vì Router giờ đã xử lý việc chặn click và pushState, Sidebar không cần làm những việc đó nữa. Thay vào đó, Sidebar sẽ lắng nghe sự kiện routeChange (mà Router sẽ dispatch sau khi định tuyến) để cập nhật trạng thái active của các liên kết.

JavaScript

// src/components/Sidebar.js
import './Sidebar.scss';

export class Sidebar {
    constructor() {
        this.sidebarElement = null;
    }

    render() {
        this.sidebarElement = document.createElement('aside');
        this.sidebarElement.innerHTML = /* html */ `
            <ul>
                <li><a href="/" class="nav-link" data-link>Dashboard</a></li>
                <hr>
                <li>
                    <a href="/posts" class="nav-link" data-link>Tất cả Bài viết</a>
                    <ul>
                        <li><a href="/post/create" data-link>Thêm Mới</a></li>
                        <li><a href="/category/post" data-link>Danh mục bài viết</a></li>
                    </ul>
                </li>
                <hr>
                <li>
                    <a href="/product" class="nav-link" data-link>Tất cả Sản Phẩm</a>
                    <ul>
                        <li><a href="/product/create" data-link>Thêm Mới</a></li>
                        <li><a href="/category/product" data-link>Danh mục Sản phẩm</a></li>
                    </ul>
                </li>
                <hr>
                <li><a href="/settings" class="nav-link" data-link>Cài đặt</a></li>
                <hr>
                <li><a href="/logout" class="nav-link" data-link>Logout</a></li>
            </ul>
        `;
        return this.sidebarElement;
    }

    // Phương thức để gắn các sự kiện
    addEventListeners() {
        if (!this.sidebarElement) {
            console.warn("Sidebar element not rendered yet. Call render() first.");
            return;
        }

        // --- Thay đổi: Sidebar không lắng nghe click nữa ---
        // --- Sidebar sẽ lắng nghe sự kiện 'routeChange' từ Router ---
        window.addEventListener('routeChange', (e) => {
            this.setActiveLinkFromPath(e.detail);
        });
        // -----------------------------------------------------------

        // Thiết lập active ban đầu khi sidebar được render
        this.setActiveLinkFromPath(window.location.pathname);
    }

    setActiveLinkFromPath(path) {
        if (!this.sidebarElement) return;

        const allLinks = this.sidebarElement.querySelectorAll('a[data-link]');

        allLinks.forEach(link => {
            link.classList.remove('active', 'parent-active');
        });

        allLinks.forEach(link => {
            if (link.getAttribute('href') === path) {
                link.classList.add('active');

                const parentLi = link.closest('li');
                const subMenu = parentLi.querySelector('ul');

                if (subMenu) { // Nếu link này là cha của một sub-menu
                     link.classList.add('parent-active');
                } else { // Nếu link này là con trong sub-menu
                    const parentUl = link.closest('ul'); // Thay vì .sub-menu, dùng ul trực tiếp hoặc thêm class .sub-menu vào html
                    if (parentUl && parentUl.previousElementSibling && parentUl.previousElementSibling.matches('a[data-link]')) {
                        parentUl.previousElementSibling.classList.add('parent-active');
                    }
                }
            }
        });
    }

    init() {
        const renderedElement = this.render();
        this.addEventListeners();
        return renderedElement;
    }
}
3. app.js (Không thay đổi đáng kể)
app.js vẫn giữ nguyên cấu trúc, chỉ là bây giờ Router và Sidebar làm việc độc lập hơn.

JavaScript

// app.js
import './style.scss';
import { Header } from './components/Header.js';
import { Sidebar } from './components/Sidebar.js';
import { Router } from './core/Router.js';

function tt(message) {
    console.log(message);
}

document.addEventListener('DOMContentLoaded', () => {
    const appContainer = document.getElementById('app');
    const mainContentArea = document.getElementById('content');

    // Header
    const headerInstance = new Header();
    const header = headerInstance.render();
    appContainer.appendChild(header);

    // Sidebar
    const sidebarInstance = new Sidebar();
    const sidebar = sidebarInstance.init();
    appContainer.appendChild(sidebar);

    // Định nghĩa các routes
    const routes = [
        { path: '/', view: () => `<h1>Dashboard</h1>` },
        { path: '/posts', view: () => `<h1>Tất cả Bài viết</h1>` },
        { path: '/post/create', view: () => `<h1>Thêm Mới Bài viết</h1>` },
        { path: '/category/post', view: () => `<h1>Danh mục Bài viết</h1>` },
        { path: '/product', view: () => `<h1>Tất cả Sản Phẩm</h1>` },
        { path: '/product/create', view: () => `<h1>Thêm Mới Sản Phẩm</h1>` },
        { path: '/category/product', view: () => `<h1>Danh mục Sản phẩm</h1>` },
        { path: '/settings', view: () => `<h1>Cài đặt</h1>` },
        { path: '/logout', view: () => `<h1>Đăng xuất</h1>` },
        {
            path: '/post/:id',
            view: (params) => `<h1>Chi tiết Bài viết: ${params.id}</h1>`
        },
    ];

    // Khởi tạo Router
    const routerInstance = new Router('content', routes);
    tt('Router and Sidebar initialized!');
});
Ưu điểm của cách tiếp cận này:
Tách biệt trách nhiệm (Separation of Concerns):
Router: Chịu trách nhiệm duy nhất về định tuyến (thay đổi URL, khớp URL với route, render nội dung) và quản lý các sự kiện thay đổi URL (click data-link, popstate).
Sidebar/Menu: Chịu trách nhiệm duy nhất về UI của menu và phản ứng với các thay đổi route để cập nhật trạng thái active.
Mở rộng dễ dàng hơn: Bạn có thể thêm các liên kết data-link ở bất cứ đâu trong ứng dụng của mình (ví dụ: trong nội dung chính, footer) và Router sẽ tự động xử lý chúng. Bạn không cần phải nhớ gắn listener cho từng liên kết mới.
Giảm code trùng lặp: Loại bỏ việc Sidebar cũng phải quản lý history.pushState và kiểm tra e.preventDefault().